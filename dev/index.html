<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · InvariantModels.jl</title><meta name="title" content="Home · InvariantModels.jl"/><meta property="og:title" content="Home · InvariantModels.jl"/><meta property="twitter:title" content="Home · InvariantModels.jl"/><meta name="description" content="Documentation for InvariantModels.jl."/><meta property="og:description" content="Documentation for InvariantModels.jl."/><meta property="twitter:description" content="Documentation for InvariantModels.jl."/><meta property="og:url" content="https://rsnumerics.github.io/InvariantModels.jl/"/><meta property="twitter:url" content="https://rsnumerics.github.io/InvariantModels.jl/"/><link rel="canonical" href="https://rsnumerics.github.io/InvariantModels.jl/"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>InvariantModels.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Set-up"><span>Set-up</span></a></li><li><a class="tocitem" href="#Data-representation"><span>Data representation</span></a></li><li><a class="tocitem" href="#Why-invariant-foliations"><span>Why invariant foliations</span></a></li><li><a class="tocitem" href="#Invariant-Foliations"><span>Invariant Foliations</span></a></li><li><a class="tocitem" href="#Invariant-Manifolds"><span>Invariant Manifolds</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#API"><span>API</span></a></li></ul></li><li><a class="tocitem" href="Tutorial/">Tutorial</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/rsnumerics/InvariantModels.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/rsnumerics/InvariantModels.jl/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Invariant-Models"><a class="docs-heading-anchor" href="#Invariant-Models">Invariant Models</a><a id="Invariant-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Invariant-Models" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/rsnumerics/InvariantModels.jl">InvariantModels</a>.</p><p>The primary goal of this software package is to identify mathematical models from data.  The identified model can be forced, parameter dependent or autonomous. The mathematical structure of the identified model is a series of invariant foliations. To avoid overfitting the foliation representation can be adjusted.  In general, encoders are represented as compressed polynomials, while the underlying low-dimensional model is an ordinary multivariate polynomial.</p><p>The software calculates invariant manifolds in vector fields and maps using a direct numerical method. The invariance equation discretised using a mixed Fourier and piecewise-Chebyshev collocation scheme.  Then the discretised equations are solved using a similar method to pseude-archlength continuation, which employs a phase and arclength condition. This is much more accurate than using series expansions about the steady state and does not suffer from small radii of convergence.</p><p>There are extensive utilities to prepare data for model identification.  These include delay embedding and dynamic mode decomposition to find ideal delay embedding coordinates. Approximate linear models can be decomposed into invariant vector bundles to provide an optimal coordinate system for model identification.</p><h2 id="Set-up"><a class="docs-heading-anchor" href="#Set-up">Set-up</a><a id="Set-up-1"></a><a class="docs-heading-anchor-permalink" href="#Set-up" title="Permalink"></a></h2><p>The system to be identified is in the skew-product form</p><p class="math-container">\[\begin{aligned}
    \boldsymbol{x}_{k+1} &amp;= \boldsymbol{f} \left(\boldsymbol{x}_{k}, \boldsymbol{\theta} \right)\\
    \boldsymbol{\theta}_{k+1} &amp;= \boldsymbol{g}( \boldsymbol{\theta}_{k} )
\end{aligned} \tag{MAP},\]</p><p>where <span>$\boldsymbol{f}\in X\times Y\to X$</span>, <span>$\boldsymbol{g}:Y\to Y$</span> are functions defined on the <span>$d_{X}$</span>-dimensional linear space <span>$X$</span> and <span>$d_{Y}$</span>-dimensional differentiable manifold <span>$Y$</span>, respectively. The forcing map <span>$\boldsymbol{g}$</span> is volume preserving, hence it has recurrent dynamics.</p><p>Every volume preserving map can be transformed into a coordinate system where its representation is approximately a unitary matrix.  To find the unitary matrix <span>$\boldsymbol{\Omega}$</span> we use the transformation</p><p class="math-container">\[\boldsymbol{\alpha} = \boldsymbol{\Psi}(\boldsymbol{\theta}),\]</p><p>where <span>$\boldsymbol{\Psi}$</span> is a vector of linearly independent scalar valued functions. It is known that as the dimensionality of <span>$\boldsymbol{\Psi}$</span> increases, the volume preserving map <span>$\boldsymbol{g}$</span> transforms into a linear unitary map <span>$\boldsymbol{\Omega}$</span> [KKS16], [KM17]. Another consequence of the transformation is that, when transformed, function <span>$\boldsymbol{f}$</span> becomes linear in new variables <span>$\boldsymbol{\alpha}$</span>.</p><p>Accordingly, system (<a href>MAP</a>) is written in the form of</p><p class="math-container">\[\begin{aligned}
    \boldsymbol{x}_{k+1} &amp;= \boldsymbol{F} \left(\boldsymbol{x}_{k}\right) \boldsymbol{\alpha}\\
    \boldsymbol{\alpha}_{k+1} &amp;= \boldsymbol{\Omega} \boldsymbol{\alpha}_{k},
\end{aligned} \tag{MAP-TR}\]</p><p>where <span>$\boldsymbol{x}_{k} \in \mathbb{R}^n$</span> is the state variable, <span>$\boldsymbol{\alpha} \in \mathbb{R}^m$</span> is the <strong>encoded</strong> phase variable.</p><h2 id="Data-representation"><a class="docs-heading-anchor" href="#Data-representation">Data representation</a><a id="Data-representation-1"></a><a class="docs-heading-anchor-permalink" href="#Data-representation" title="Permalink"></a></h2><p>The data is a set of <span>$N$</span> trajectories, each of which are <span>$\ell_{j}-\ell_{j-1}$</span> points long for <span>$j=1,\ldots,N$</span>, where <span>$\ell_{0}=0$</span>. In formulae the trajectories are </p><p class="math-container">\[\begin{align*}
    \left(\boldsymbol{x}_{1},\boldsymbol{\alpha}_{1}\right),\left(\boldsymbol{x}_{2},\boldsymbol{\alpha}_{2}\right),\ldots,\left(\boldsymbol{x}_{\ell_{1}},\boldsymbol{\alpha}_{\ell_{1}}\right) &amp; \\
    \vdots \qquad \qquad &amp; \\
    \left(\boldsymbol{x}_{\ell_{N-1}+1},\boldsymbol{\alpha}_{\ell_{N-1}+1}\right),\left(\boldsymbol{x}_{\ell_{N-1}+2},\boldsymbol{\alpha}_{\ell_{N-1}+2}\right),\ldots,\left(\boldsymbol{x}_{\ell_{N}},\boldsymbol{\alpha}_{\ell_{N}}\right) &amp;
\end{align*}\]</p><p>Here <span>$\boldsymbol{\alpha}$</span> represent the state of the forcing dynamics as encoded by the <span>$\boldsymbol{\Psi}$</span> function. </p><p>The data is arranged into two arrays. The array <code>Data</code> is simply the state</p><p class="math-container">\[\begin{pmatrix} 
    \boldsymbol{x}_{1} &amp; \boldsymbol{x}_{2} &amp; \cdots &amp; \boldsymbol{x}_{\ell_N}
\end{pmatrix}\]</p><p>The second array <code>Encoded_Phase</code> contains the forcing states</p><p class="math-container">\[\begin{pmatrix} 
    \boldsymbol{\alpha}_{1} &amp; \boldsymbol{\alpha}_{2} &amp; \cdots &amp; \boldsymbol{\alpha}_{\ell_N}
\end{pmatrix}\]</p><p>To make sure that the system know where each trajectory starts and ends, we also must supply the <code>Index_List</code> vector</p><p class="math-container">\[\begin{pmatrix} 
    \ell_{0} &amp; \ell_{1} &amp; \cdots &amp; \ell_N
\end{pmatrix}.\]</p><h2 id="Why-invariant-foliations"><a class="docs-heading-anchor" href="#Why-invariant-foliations">Why invariant foliations</a><a id="Why-invariant-foliations-1"></a><a class="docs-heading-anchor-permalink" href="#Why-invariant-foliations" title="Permalink"></a></h2><p>Invariant foliations are the only architecture that guarantees invariance and uniqueness (under some smoothness and non-resonance conditions) at the same time [Sza20, Sza23].</p><p>All dynamic model reduction architectures can be put into four categories.  Each architecture must contain functional connections between the model and the data.  This functional connection can only go two ways: from the data to the model or in reverse, which are the encoders and decoders, respectively.  One has to establish this connection both at the initial condition and at the model prediction. This is exactly four combinations.</p><p>There are four ways to connect a low-order model <span>$\boldsymbol{R}$</span> to <span>$\boldsymbol{F}$</span>. The figure below shows the four combinations. Only invariant foliations and invariant manifolds produce meaningful reduced order models. Only invariant foliations and autoencoders can be fitted to data. The intersection is invariant foliations.</p><p><img src="FourDiag-Plain.svg" alt/></p><p>Therefore,</p><ul><li>when a <strong>system of equations</strong> is given, invariant manifolds are the most appropriate (foliations are still possible),</li><li>when <strong>data</strong> is given, only invariant foliations are appropriate.</li></ul><p>Autoencoders such as <a href="https://github.com/haller-group/SSMLearn">SSMLearn</a> do not enforce invariance and therefore generate spurious results as shown in [Sza23].</p><h2 id="Invariant-Foliations"><a class="docs-heading-anchor" href="#Invariant-Foliations">Invariant Foliations</a><a id="Invariant-Foliations-1"></a><a class="docs-heading-anchor-permalink" href="#Invariant-Foliations" title="Permalink"></a></h2><p>The sofware identifies the encoder <span>$\boldsymbol{U}$</span> and the conjugate map <span>$\boldsymbol{R}$</span> from the invariance equation</p><p class="math-container">\[\boldsymbol{R}\left(\boldsymbol{U}\left(\boldsymbol{x},\boldsymbol{\theta}\right),\boldsymbol{\theta}\right) = \boldsymbol{U}\left(\boldsymbol{f}\left(\boldsymbol{x},\boldsymbol{\theta}\right),\boldsymbol{g}\left(\boldsymbol{\theta}\right)\right). \tag{FOIL}\]</p><p>Equation (<a href>FOIL</a>) is turned into a least squares optimisation problem and the loss function is minimised.</p><h2 id="Invariant-Manifolds"><a class="docs-heading-anchor" href="#Invariant-Manifolds">Invariant Manifolds</a><a id="Invariant-Manifolds-1"></a><a class="docs-heading-anchor-permalink" href="#Invariant-Manifolds" title="Permalink"></a></h2><p>The sofware also calculates invariant manifolds from maps and vector fields. The invariance for manifolds is</p><p class="math-container">\[\boldsymbol{S}\left(\boldsymbol{V}\left(\boldsymbol{x},\boldsymbol{\theta}\right),\boldsymbol{\theta}\right) = \boldsymbol{V}\left(\boldsymbol{f}\left(\boldsymbol{x},\boldsymbol{\theta}\right),\boldsymbol{g}\left(\boldsymbol{\theta}\right)\right), \tag{MAN}\]</p><p>where <span>$\boldsymbol{V}$</span> is the decoder and <span>$\boldsymbol{S}$</span> is the conjugate map. Since we are interested in oscilllatory dynamics on 2D manifolds, the invariance equation can be written in polar coordinates, that is</p><p class="math-container">\[\boldsymbol{V}\left(R\left(\rho\right),T\left(\rho\right),\boldsymbol{g}\left(\boldsymbol{\theta}\right)\right)=\boldsymbol{f}\left(\boldsymbol{V}\left(\rho,\beta,\boldsymbol{\theta}\right),\boldsymbol{\theta}\right),\]</p><p>where <span>$R$</span> and <span>$T$</span> represent the conjugate dynamics. The parametrisation of the invariant manifold is fixed by the amplitude and phase conditions</p><p class="math-container">\[\begin{aligned}
    \int_{Y}\int_{0}^{2\pi}\left\langle D_{1}\boldsymbol{V}\left(\rho,\beta,\boldsymbol{\theta}\right),\boldsymbol{V}\left(\rho,\beta,\boldsymbol{\theta}\right)-\boldsymbol{V}\left(0,\beta,\boldsymbol{\theta}\right)\right\rangle \mathrm{d}\beta\mathrm{d}\boldsymbol{\theta} &amp;= \rho \\
    \int_{Y}\int_{0}^{2\pi}\left\langle D_{1}\boldsymbol{V}\left(r,\beta,\boldsymbol{\theta}\right),D_{2}\boldsymbol{V}\left(r,\beta,\boldsymbol{\theta}\right)\right\rangle \mathrm{d}\beta\mathrm{d}\boldsymbol{\theta} &amp;= 0.
\end{aligned}\]</p><p>The instantantaneous damping ratio and frequency are calculated as</p><p class="math-container">\[\begin{aligned}
\zeta\left(\rho\right)	&amp;=-\frac{\frac{\mathrm{d}}{\mathrm{d}\rho}R\left(\rho\right)}{T\left(\rho\right)}\;\;\text{and}\\
\omega\left(\rho\right)	&amp;=T\left(\rho\right),
\end{aligned}\]</p><p>respectively.</p><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><div class="citation noncanonical"><dl><dt>[KKS16]</dt><dd><div>S. Klus, P. Koltai and C. Schütte. <a href="https://me.me"><em>On the numerical approximation of the Perron-Frobenius and Koopman operator</em></a>. <a href="https://doi.org/10.3934/jcd.2016003">Journal of Computational Dynamics <strong>3</strong>, 51–79</a> (2016).</div></dd><dt>[KM17]</dt><dd><div>M. Korda and I. Mezić. <em>On Convergence of Extended Dynamic Mode Decomposition to the Koopman Operator</em>. <a href="https://doi.org/10.1007/s00332-017-9423-0">Journal of Nonlinear Science <strong>28</strong>, 687–710</a> (2017).</div></dd><dt>[Sza20]</dt><dd><div>R. Szalai. <em>Invariant spectral foliations with applications to model order reduction and synthesis</em>. <a href="https://doi.org/10.1007/s11071-020-05891-1">Nonlinear Dynamics <strong>101</strong>, 2645–2669</a> (2020).</div></dd><dt>[Sza23]</dt><dd><div>R. Szalai. <em>Data-Driven Reduced Order Models Using Invariant Foliations, Manifolds and Autoencoders</em>. <a href="https://doi.org/10.1007/s00332-023-09932-y">Journal of Nonlinear Science <strong>33</strong>, 75</a> (2023).</div></dd></dl></div><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#InvariantModels.Encoder_Linear_Type"><code>InvariantModels.Encoder_Linear_Type</code></a></li><li><a href="#InvariantModels.Encoder_Nonlinear_Type"><code>InvariantModels.Encoder_Nonlinear_Type</code></a></li><li><a href="#InvariantModels.MultiStep_Model"><code>InvariantModels.MultiStep_Model</code></a></li><li><a href="#InvariantModels.Multi_Foliation_Problem"><code>InvariantModels.Multi_Foliation_Problem</code></a></li><li><a href="#InvariantModels.Scaling_Type"><code>InvariantModels.Scaling_Type</code></a></li><li><a href="#InvariantModels.Annotate_Plot!"><code>InvariantModels.Annotate_Plot!</code></a></li><li><a href="#InvariantModels.Barycentric_Interpolation_Matrix"><code>InvariantModels.Barycentric_Interpolation_Matrix</code></a></li><li><a href="#InvariantModels.Chebyshev_Grid"><code>InvariantModels.Chebyshev_Grid</code></a></li><li><a href="#InvariantModels.Chop_And_Stitch"><code>InvariantModels.Chop_And_Stitch</code></a></li><li><a href="#InvariantModels.Create_Linear_Decomposition"><code>InvariantModels.Create_Linear_Decomposition</code></a></li><li><a href="#InvariantModels.Create_Plot"><code>InvariantModels.Create_Plot</code></a></li><li><a href="#InvariantModels.Data_Error"><code>InvariantModels.Data_Error</code></a></li><li><a href="#InvariantModels.Data_Result"><code>InvariantModels.Data_Result</code></a></li><li><a href="#InvariantModels.Decompose_Data"><code>InvariantModels.Decompose_Data</code></a></li><li><a href="#InvariantModels.Decomposed_Data_Scaling"><code>InvariantModels.Decomposed_Data_Scaling</code></a></li><li><a href="#InvariantModels.Delay_Embed"><code>InvariantModels.Delay_Embed</code></a></li><li><a href="#InvariantModels.Estimate_Linear_Model"><code>InvariantModels.Estimate_Linear_Model</code></a></li><li><a href="#InvariantModels.Evaluate"><code>InvariantModels.Evaluate</code></a></li><li><a href="#InvariantModels.Extract_Manifold_Embedding"><code>InvariantModels.Extract_Manifold_Embedding</code></a></li><li><a href="#InvariantModels.Filter_Linear_Model"><code>InvariantModels.Filter_Linear_Model</code></a></li><li><a href="#InvariantModels.Find_DATA_Manifold"><code>InvariantModels.Find_DATA_Manifold</code></a></li><li><a href="#InvariantModels.Find_MAP_Manifold"><code>InvariantModels.Find_MAP_Manifold</code></a></li><li><a href="#InvariantModels.Find_ODE_Manifold"><code>InvariantModels.Find_ODE_Manifold</code></a></li><li><a href="#InvariantModels.Fourier_Grid"><code>InvariantModels.Fourier_Grid</code></a></li><li><a href="#InvariantModels.Fourier_Interpolate"><code>InvariantModels.Fourier_Interpolate</code></a></li><li><a href="#InvariantModels.From_Data!"><code>InvariantModels.From_Data!</code></a></li><li><a href="#InvariantModels.Generate_From_ODE"><code>InvariantModels.Generate_From_ODE</code></a></li><li><a href="#InvariantModels.Make_Similar"><code>InvariantModels.Make_Similar</code></a></li><li><a href="#InvariantModels.Model_From_Function_Alpha"><code>InvariantModels.Model_From_Function_Alpha</code></a></li><li><a href="#InvariantModels.Model_From_ODE"><code>InvariantModels.Model_From_ODE</code></a></li><li><a href="#InvariantModels.Model_Result"><code>InvariantModels.Model_Result</code></a></li><li><a href="#InvariantModels.Multi_Foliation_Test_Problem"><code>InvariantModels.Multi_Foliation_Test_Problem</code></a></li><li><a href="#InvariantModels.Optimise!"><code>InvariantModels.Optimise!</code></a></li><li><a href="#InvariantModels.Plot_Error_Curves!"><code>InvariantModels.Plot_Error_Curves!</code></a></li><li><a href="#InvariantModels.Plot_Error_Trace"><code>InvariantModels.Plot_Error_Trace</code></a></li><li><a href="#InvariantModels.Rigid_Rotation_Generator"><code>InvariantModels.Rigid_Rotation_Generator</code></a></li><li><a href="#InvariantModels.Rigid_Rotation_Matrix!"><code>InvariantModels.Rigid_Rotation_Matrix!</code></a></li><li><a href="#InvariantModels.Select_Bundles_By_Energy"><code>InvariantModels.Select_Bundles_By_Energy</code></a></li><li><a href="#InvariantModels.Slice"><code>InvariantModels.Slice</code></a></li></ul><h2 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h2><h3 id="Fourier-collocation"><a class="docs-heading-anchor" href="#Fourier-collocation">Fourier collocation</a><a id="Fourier-collocation-1"></a><a class="docs-heading-anchor-permalink" href="#Fourier-collocation" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="InvariantModels.Fourier_Grid"><a class="docstring-binding" href="#InvariantModels.Fourier_Grid"><code>InvariantModels.Fourier_Grid</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Fourier_Grid(Phase_Dimension::Integer)</code></pre><p>Creates a uniform grid on the <span>$[0, 2\pi)$</span> interval.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rsnumerics/InvariantModels.jl/blob/9ad165561d2f467e3161f454b25e89ab819413fc/src/Fourier_Utils.jl#L125-L129">source</a></section></details></article><article><details class="docstring" open="true"><summary id="InvariantModels.Fourier_Interpolate"><a class="docstring-binding" href="#InvariantModels.Fourier_Interpolate"><code>InvariantModels.Fourier_Interpolate</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Fourier_Interpolate(grid, theta::Number)</code></pre><p>Evaluates the set of Dirichlet kernels specific to the uniform <code>grid</code> at point theta. The result is a vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rsnumerics/InvariantModels.jl/blob/9ad165561d2f467e3161f454b25e89ab819413fc/src/Fourier_Utils.jl#L28-L33">source</a></section><section><div><pre><code class="language-julia hljs">Fourier_Interpolate(grid, theta::AbstractArray{T,1}) where {T}</code></pre><p>Evaluates the set of Dirichlet kernels specific to the uniform <code>grid</code> at all points in <code>theta</code>. The result is a matrix, where each column corresponds to a value in <code>theta</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rsnumerics/InvariantModels.jl/blob/9ad165561d2f467e3161f454b25e89ab819413fc/src/Fourier_Utils.jl#L97-L102">source</a></section></details></article><article><details class="docstring" open="true"><summary id="InvariantModels.Rigid_Rotation_Matrix!"><a class="docstring-binding" href="#InvariantModels.Rigid_Rotation_Matrix!"><code>InvariantModels.Rigid_Rotation_Matrix!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Rigid_Rotation_Matrix!(Alpha_Matrix, Grid, Omega_ODE::Number, t::Number)</code></pre><p>Creates the fundamental solution matrix for the rigid rotation on the circle in the space of the uniform <code>Grid</code> on the circle. The angular speed of the rotation is <code>Omega_ODE</code> and the result is written into <code>Alpha_Matrix</code>. The indepedent variabe is <code>t</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rsnumerics/InvariantModels.jl/blob/9ad165561d2f467e3161f454b25e89ab819413fc/src/Fourier_Utils.jl#L67-L72">source</a></section></details></article><article><details class="docstring" open="true"><summary id="InvariantModels.Rigid_Rotation_Generator"><a class="docstring-binding" href="#InvariantModels.Rigid_Rotation_Generator"><code>InvariantModels.Rigid_Rotation_Generator</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Rigid_Rotation_Generator(Grid, Omega_ODE::Number)</code></pre><p>This is the infinitesimal generator of the rigid rotation with <code>Omega_ODE</code> angular speed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rsnumerics/InvariantModels.jl/blob/9ad165561d2f467e3161f454b25e89ab819413fc/src/Fourier_Utils.jl#L82-L86">source</a></section></details></article><h3 id="One-dimensional-polynomial-collocation-and-interpolation"><a class="docs-heading-anchor" href="#One-dimensional-polynomial-collocation-and-interpolation">One-dimensional polynomial collocation and interpolation</a><a id="One-dimensional-polynomial-collocation-and-interpolation-1"></a><a class="docs-heading-anchor-permalink" href="#One-dimensional-polynomial-collocation-and-interpolation" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="InvariantModels.Chebyshev_Grid"><a class="docstring-binding" href="#InvariantModels.Chebyshev_Grid"><code>InvariantModels.Chebyshev_Grid</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Chebyshev_Grid(np::Integer)</code></pre><p>Creates a Chebyshev grid with <code>np</code> grid points.</p><p class="math-container">\[t_j = \cos\frac{(j-1) \pi }{n-1},\;\; j =1,\ldots,n\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rsnumerics/InvariantModels.jl/blob/9ad165561d2f467e3161f454b25e89ab819413fc/src/Polynomial_Interpolation.jl#L7-L14">source</a></section><section><div><pre><code class="language-julia hljs">Chebyshev_Grid(np::Integer, a::T, b::T) where {T&lt;:Number}</code></pre><p>Creates a Chebyshev grid with <code>np</code> grid points within the interval <span>$[a, b]$</span>.</p><p class="math-container">\[t_j = \frac{a+b}{2} + \frac{a-b}{2} \cos\frac{(j-1) \pi }{n-1},\;\; j =1,\ldots,n\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rsnumerics/InvariantModels.jl/blob/9ad165561d2f467e3161f454b25e89ab819413fc/src/Polynomial_Interpolation.jl#L19-L26">source</a></section></details></article><article><details class="docstring" open="true"><summary id="InvariantModels.Barycentric_Interpolation_Matrix"><a class="docstring-binding" href="#InvariantModels.Barycentric_Interpolation_Matrix"><code>InvariantModels.Barycentric_Interpolation_Matrix</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Barycentric_Interpolation_Matrix(t::AbstractVector, ti::AbstractVector)</code></pre><p>Creates a matrix that performs a polynomial interpolation from grid <code>t</code> to grid <code>ti</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rsnumerics/InvariantModels.jl/blob/9ad165561d2f467e3161f454b25e89ab819413fc/src/Polynomial_Interpolation.jl#L82-L86">source</a></section><section><div><pre><code class="language-julia hljs">Barycentric_Interpolation_Matrix(order::Integer, mesh::Vector, ti::AbstractVector)</code></pre><p>Creates a matrix that performs a polynomial interpolation from a <code>mesh</code>, where each interval has <code>order</code> number of Chebyshev points. The target points are in <code>grid</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rsnumerics/InvariantModels.jl/blob/9ad165561d2f467e3161f454b25e89ab819413fc/src/Polynomial_Interpolation.jl#L107-L112">source</a></section></details></article><h3 id="Data-pre-processing"><a class="docs-heading-anchor" href="#Data-pre-processing">Data pre-processing</a><a id="Data-pre-processing-1"></a><a class="docs-heading-anchor-permalink" href="#Data-pre-processing" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="InvariantModels.Delay_Embed"><a class="docstring-binding" href="#InvariantModels.Delay_Embed"><code>InvariantModels.Delay_Embed</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Delay_Embed(Signals, Phases; delay = 1, skip = 1, max_length = typemax(Int))</code></pre><p>Creates a delay embedding of <code>Signals</code> while limits trajectory length to <code>max_length</code>. The delay is <code>delay</code> long and only every <code>skip</code>th point along the trajectory is put into the delay embedded data. <code>Phases</code> are simply copied over to the output while making sure that signal lengths and phase length are the same, limited by <code>max_length</code>.</p><p>The return values <code>Delay_Signals</code>, <code>Delay_Phases</code> are matrices of appropriate sizes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rsnumerics/InvariantModels.jl/blob/9ad165561d2f467e3161f454b25e89ab819413fc/src/Data_Wrangling.jl#L46-L54">source</a></section></details></article><article><details class="docstring" open="true"><summary id="InvariantModels.Chop_And_Stitch"><a class="docstring-binding" href="#InvariantModels.Chop_And_Stitch"><code>InvariantModels.Chop_And_Stitch</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Chop_And_Stitch(Signals, Phases; maxlen = 1000)</code></pre><p>Chops up <code>Signals</code> and <code>Phases</code> into chunks of maximum <code>maxlen</code> chuncks. Then concatenates the result into the arrays <code>Index_List</code>, <code>Data</code>, <code>Encoded_Phase</code>. The list <code>Index_List</code> tells, where each chunk starts and ends within the arrays <code>Data</code> and <code>Encoded_Phase</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rsnumerics/InvariantModels.jl/blob/9ad165561d2f467e3161f454b25e89ab819413fc/src/Data_Wrangling.jl#L92-L99">source</a></section></details></article><article><details class="docstring" open="true"><summary id="InvariantModels.Estimate_Linear_Model"><a class="docstring-binding" href="#InvariantModels.Estimate_Linear_Model"><code>InvariantModels.Estimate_Linear_Model</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Estimate_Linear_Model(
    Index_List,
    Data,
    Encoded_Phase,
    Scaling;
    Iterations = 0,
    Order = 1,
)</code></pre><p>Given the data <code>Index_List</code>, <code>Data</code>, <code>Encoded_Phase</code> this function estimates a linear model, a steady state and a model of forcing.</p><p>The output is <code>Steady_State</code>, <code>BB_Linear</code>, <code>SH</code>. <code>Steady_State</code> is the steady state of the system, <code>BB_Linear</code> is the estimated linear model and <code>SH</code> is the unitary transformation representing forcing.</p><p>When fitting the linear model <code>Scaling</code> attaches an importance to each data point. <code>Iterations</code> allows us to take into account the data as trajectories and use multi-step optimisation to find <code>BB_Linear</code>. A nonlinear model can also be fitted by making <code>Order</code> <span>$&gt; 1$</span>. When a nonlinear model is identified, its steady state is found by Newton&#39;s method and its Jacobian is calculated at the steady state, which is then returned as the linear model <code>BB_Linear</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rsnumerics/InvariantModels.jl/blob/9ad165561d2f467e3161f454b25e89ab819413fc/src/Data_Wrangling.jl#L324-L345">source</a></section></details></article><article><details class="docstring" open="true"><summary id="InvariantModels.Filter_Linear_Model"><a class="docstring-binding" href="#InvariantModels.Filter_Linear_Model"><code>InvariantModels.Filter_Linear_Model</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Filter_Linear_Model(BB, Grid, order)</code></pre><p>Assuming a uniform Fourier grid <code>Grid</code>, this function returns a truncated Fourier series of the linear model <code>BB</code>. This removes inaccurate higher frequency components of the approximate linear model before decomposing it into invariant vector bundles.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rsnumerics/InvariantModels.jl/blob/9ad165561d2f467e3161f454b25e89ab819413fc/src/Data_Wrangling.jl#L302-L307">source</a></section></details></article><article><details class="docstring" open="true"><summary id="InvariantModels.Create_Linear_Decomposition"><a class="docstring-binding" href="#InvariantModels.Create_Linear_Decomposition"><code>InvariantModels.Create_Linear_Decomposition</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Create_Linear_Decomposition(
    BB_Filtered,
    SH;
    Time_Step = 1.0,
    Reduce = false,
    Align = true,
    By_Eigen = false,
)</code></pre><p>Creates an invariant vector bundle decomposition of the linear system represented by <code>BB_Filtered</code> and the forcing dynamics <code>SH</code>. If <code>Time_Step</code> is specified, the fucntion also prints the estimated natural frequencies and damping ratios. The decomposition outputs vector bundles with orthonormal bases. Therefore the reduced model will be block-diagonal (with at most <span>$2\times 2$</span> blocks), but not autonomous. If <code>Reduce == true</code> the system will be reduced to an autonomous form and the vector bundles will only be orthogonal in a weaker sense, averaged over the phase space of the forcing dyamics.</p><p>The output is a named tuple</p><pre><code class="language-julia hljs">(
    Unreduced_Model,
    Data_Encoder,
    Data_Decoder,
    Bundles,
    Reduced_Model,
    Reduced_Encoder,
    Reduced_Decoder,
)</code></pre><p>where</p><ul><li><code>Unreduced_Model</code> is the block diagonal, but non-autonomous model.</li><li><code>Data_Encoder</code> is the transformation that brings the data into the block-diagonal form.</li><li><code>Data_Decoder</code> is the transformation that brings the model back into the coordinate system of the data.</li><li><code>Bundles</code> is a list of ranges that point out which entries of the <code>Unreduced_Model</code> are a vector bundle.</li><li><code>Reduced_Model</code> is the autonomous reduced model, if <code>Reduce == true</code>, otherwise same as <code>Unreduced_Model</code>.</li><li><code>Reduced_Encoder</code> brings <code>Unreduced_Model</code> into <code>Reduced_Model</code> if <code>Reduce == true</code> otherwise identity.</li><li><code>Reduced_Decoder</code> brings <code>Reduced_Model</code> back into <code>Unreduced_Model</code> if <code>Reduce == true</code> otherwise identity.</li></ul><p>The parameter <code>By_Eigen</code> is true if the calculation is carried out by eigenvalue decomposition of the transport operator. Otherwise a specially designed Hessenberg transformation and subsequent QR iteration is carried out on the vector bundles. This latter method</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rsnumerics/InvariantModels.jl/blob/9ad165561d2f467e3161f454b25e89ab819413fc/src/Data_Wrangling.jl#L420-L460">source</a></section></details></article><article><details class="docstring" open="true"><summary id="InvariantModels.Select_Bundles_By_Energy"><a class="docstring-binding" href="#InvariantModels.Select_Bundles_By_Energy"><code>InvariantModels.Select_Bundles_By_Energy</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Select_Bundles_By_Energy(
    Index_List,
    Data,
    Encoded_Phase,
    Steady_State,
    SH,
    Decomp;
    How_Many,
    Ignore_Real = true,
)</code></pre><p>Takes the named tuple produced by <a href="#InvariantModels.Create_Linear_Decomposition"><code>Create_Linear_Decomposition</code></a> and selects the most energetic <code>How_Many</code> vector bundles of the data. Then produces a new named touple as in <a href="#InvariantModels.Create_Linear_Decomposition"><code>Create_Linear_Decomposition</code></a>, that only contains these most energetic vector bundles. The input arguments are</p><ul><li><code>Index_List</code>, <code>Data</code>, <code>Encoded_Phase</code> are the training data in the standard form.</li><li><code>Steady_State</code> is the steady state of the system estimated by <a href="#InvariantModels.Estimate_Linear_Model"><code>Estimate_Linear_Model</code></a>.</li><li><code>SH</code> is the forcing dynamics as produced by <a href="#InvariantModels.Estimate_Linear_Model"><code>Estimate_Linear_Model</code></a>.</li><li><code>Decomp</code> is the named tuple produced by <a href="#InvariantModels.Create_Linear_Decomposition"><code>Create_Linear_Decomposition</code></a>.</li><li><code>Ignore_Real</code> if <code>true</code> the method only returns two dimensional vector bundles.   This is helpful when the data includes slowly varying <code>DC</code> shift with high energy that would be pick by the method otherwise.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rsnumerics/InvariantModels.jl/blob/9ad165561d2f467e3161f454b25e89ab819413fc/src/Data_Wrangling.jl#L547-L568">source</a></section></details></article><article><details class="docstring" open="true"><summary id="InvariantModels.Decompose_Data"><a class="docstring-binding" href="#InvariantModels.Decompose_Data"><code>InvariantModels.Decompose_Data</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Decompose_Data(Index_List, Data, Encoded_Phase, Steady_State, SH, Data_Encoder)</code></pre><p>Creates a decomposed and projected data set from the input <code>Index_List</code>, <code>Data</code>, <code>Encoded_Phase</code>. The <code>Steady_State</code> and <code>SH</code> are produced by <a href="#InvariantModels.Estimate_Linear_Model"><code>Estimate_Linear_Model</code></a> and <code>Data_Encoder</code> id produced by either <a href="#InvariantModels.Select_Bundles_By_Energy"><code>Select_Bundles_By_Energy</code></a> or <a href="#InvariantModels.Create_Linear_Decomposition"><code>Create_Linear_Decomposition</code></a> directly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rsnumerics/InvariantModels.jl/blob/9ad165561d2f467e3161f454b25e89ab819413fc/src/Data_Wrangling.jl#L691-L697">source</a></section></details></article><article><details class="docstring" open="true"><summary id="InvariantModels.Decomposed_Data_Scaling"><a class="docstring-binding" href="#InvariantModels.Decomposed_Data_Scaling"><code>InvariantModels.Decomposed_Data_Scaling</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Decomposed_Data_Scaling(Data_Decomp, Bundles)</code></pre><p>Creates a scaling tensor which, when applied to <code>Data_Decomp</code> makes each vector bundle have the same maximum amplitude, while also making the whole data set fit inside the unit ball.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rsnumerics/InvariantModels.jl/blob/9ad165561d2f467e3161f454b25e89ab819413fc/src/Data_Wrangling.jl#L705-L710">source</a></section></details></article><h3 id="Generating-data-from-differential-equations"><a class="docs-heading-anchor" href="#Generating-data-from-differential-equations">Generating data from differential equations</a><a id="Generating-data-from-differential-equations-1"></a><a class="docs-heading-anchor-permalink" href="#Generating-data-from-differential-equations" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="InvariantModels.Generate_From_ODE"><a class="docstring-binding" href="#InvariantModels.Generate_From_ODE"><code>InvariantModels.Generate_From_ODE</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Generate_From_ODE(
    Vectorfield!,
    Forcing_Map!,
    Alpha_Map!,
    Parameters,
    Time_Step,
    IC_x,
    IC_Force,
    IC_Alpha,
    Trajectory_Lengths,
)</code></pre><p>Generates a data set from am ordinary differential equation (ODE). The ODE is defined by the three functions <code>Vectorfield!</code>, <code>Forcing_Map!</code> and <code>Alpha_Map!</code>.</p><ul><li><code>Time_Step</code> is the sampling time interval of the soluation</li><li><code>IC_x</code> each column contains an initial condition in the state space</li><li><code>IC_Force</code> this is a storage space and will be overwritten with the actual value of the forcing state <code>Alpha</code></li><li><code>IC_Alpha</code> each column contains an initial condition of the forcing state</li><li><code>Trajectory_Lengths</code> a vector of trajectory lengths</li></ul><p>The return values are <code>List_Of_Trajectories</code>, <code>List_Of_Phases</code>, which can be further processed by identifying a linear model <a href="#InvariantModels.Estimate_Linear_Model"><code>Estimate_Linear_Model</code></a>.</p><p>An example of the ODE is</p><pre><code class="language-code hljs">function Vectorfield!(dx, x, u, Parameters)
    ... dx is the dx/dt
    ... x is the state variable vector
    ... u is the time varying input or forcing vector
    ... Parameters is a data structure that is passed around all function
        and contains all auxilliary information necessary to calculate dx
    ...
    return x
end

function `Forcing_Map!`(u, Alpha, Parameters)
    ... This function produces the forcing vector &#39;u&#39;
    ... The state variable of the forcing is `Alpha`
    ... Parameters is a data structure that is passed around all function
    ... The forcing depends on the state variable of the forcing `Alpha`
    ... In this case the forcing is just a linear combination of `Alpha`
    u[1:2] .= Parameters.Weights * Alpha
    return u
end

function Alpha_Map!(x, Parameters, t)
    ... Returns a matrix, which is the fundamental solution of the forcing dynamics
    ... &#39;x&#39; is the fundamental solution
    ... Parameters is a data structure that is passed around all function
    ... `t` is the independent time variable
    return Rigid_Rotation_Matrix!(x, Parameters.Forcing_Grid, Parameters.Omega, t)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rsnumerics/InvariantModels.jl/blob/9ad165561d2f467e3161f454b25e89ab819413fc/src/Generate_From_ODE.jl#L36-L90">source</a></section></details></article><h3 id="Types-of-encoders"><a class="docs-heading-anchor" href="#Types-of-encoders">Types of encoders</a><a id="Types-of-encoders-1"></a><a class="docs-heading-anchor-permalink" href="#Types-of-encoders" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="InvariantModels.Encoder_Linear_Type"><a class="docstring-binding" href="#InvariantModels.Encoder_Linear_Type"><code>InvariantModels.Encoder_Linear_Type</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">@enum Encoder_Linear_Type begin
    Encoder_Fixed = 0
    Encoder_Array_Stiefel = 1
    Encoder_Mean_Stiefel = 2
    Encoder_Stiefel_Oblique = 3
    Encoder_Orthogonal = 4
end</code></pre><p>Enumeration to describe the linear part of the Encoder.</p><ul><li><code>Encoder_Fixed</code> the encoder is not optimised, it is left fixed at its initial state</li><li><code>Encoder_Array_Stiefel</code> the encoder is a pointwise orthogonal set of matrices</li><li><code>Encoder_Mean_Stiefel</code> the encoder is orthogonal in an average sense over all possible forcing</li><li><code>Encoder_Stiefel_Oblique</code> the encoder consist of unit vectors for all points of forcing (not orthogonal)</li><li><code>Encoder_Orthogonal</code> the encoder is orthogonal to all linear parts of the other foliations and   this orthogonality is periodically updated with the other foliations</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rsnumerics/InvariantModels.jl/blob/9ad165561d2f467e3161f454b25e89ab819413fc/src/Encoder.jl#L3-L19">source</a></section></details></article><article><details class="docstring" open="true"><summary id="InvariantModels.Encoder_Nonlinear_Type"><a class="docstring-binding" href="#InvariantModels.Encoder_Nonlinear_Type"><code>InvariantModels.Encoder_Nonlinear_Type</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">@enum Encoder_Nonlinear_Type begin
    Encoder_Dense_Full = 0
    Encoder_Dense_Latent_Linear = 1
    Encoder_Dense_Local = 2
    Encoder_Compressed_Full = 16
    Encoder_Compressed_Latent_Linear = 17
    Encoder_Compressed_Local = 18
end</code></pre><p>Enumeration to describe the nonlinear part of the Encoder</p><ul><li><code>Encoder_Dense_Full</code> the encoder is a dense polynomial without any constraints</li><li><code>Encoder_Dense_Latent_Linear</code> the encoder is a dense polynomial, but it is linear for the latent variables</li><li><code>Encoder_Dense_Local</code> the encoder is a dense polynomial, but it is locally defined about an invariant manifold</li><li><code>Encoder_Compressed_Full</code> the encoder is a compressed polynomial without any constraints</li><li><code>Encoder_Compressed_Latent_Linear</code> the encoder is a compressed polynomial, but it is linear for the latent variables</li><li><code>Encoder_Compressed_Local</code> the encoder is a compressed polynomial, but it is locally defined about an invariant manifold</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rsnumerics/InvariantModels.jl/blob/9ad165561d2f467e3161f454b25e89ab819413fc/src/Encoder.jl#L29-L46">source</a></section></details></article><h3 id="Multivariate-polynomial-models"><a class="docs-heading-anchor" href="#Multivariate-polynomial-models">Multivariate polynomial models</a><a id="Multivariate-polynomial-models-1"></a><a class="docs-heading-anchor-permalink" href="#Multivariate-polynomial-models" title="Permalink"></a></h3><p>These models represent</p><ul><li>The conjugate dynamics</li><li>a vector field</li><li>a nonlinear map produced from a vector field</li></ul><p>The representation is used to fit full trajectories to data and therefore making it a highly nonlinear optimisation problem.</p><article><details class="docstring" open="true"><summary id="InvariantModels.MultiStep_Model"><a class="docstring-binding" href="#InvariantModels.MultiStep_Model"><code>InvariantModels.MultiStep_Model</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MultiStep_Model(State_Dimension, Skew_Dimension, Start_Order, End_Order, Trajectories)</code></pre><p>Create a polynomial model representation.</p><ul><li><code>State_Dimension</code> dimensionality of the state space</li><li><code>Skew_Dimension</code> dimensionality of the forcin space</li><li><code>Start_Order</code> the smallest order monomial to include</li><li><code>End_Order</code> the greatest order monomial to include</li><li><code>Trajectories</code> number of trajectories to be represented</li></ul><p>The model includes an identified initial condition for each fitted trajectory, which is different from the first point of the trajectory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rsnumerics/InvariantModels.jl/blob/9ad165561d2f467e3161f454b25e89ab819413fc/src/MultiStep_Model.jl#L214-L225">source</a></section></details></article><article><details class="docstring" open="true"><summary id="InvariantModels.From_Data!"><a class="docstring-binding" href="#InvariantModels.From_Data!"><code>InvariantModels.From_Data!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">From_Data!(M::MultiStep_Model, X, Index_List, Data, Encoded_Phase, Scaling; Linear=false)</code></pre><p>Creates a polynomial model from data given by <code>Index_List, Data, Encoded_Phase</code>. The model is created using linear least squares and therefore not optimised. This is to provide an initial condition for optimisation later on.</p><ul><li><code>M</code>, <code>X</code> the model representation</li><li><code>Index_List</code>, <code>Data</code> and <code>Encoded_Phase</code> input data</li><li><code>Scaling</code> a scaling factor to represent the importance of each data point</li><li><code>Linear</code> if <code>true</code> all nonlinear terms are zeroed</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rsnumerics/InvariantModels.jl/blob/9ad165561d2f467e3161f454b25e89ab819413fc/src/MultiStep_Model.jl#L538-L548">source</a></section></details></article><article><details class="docstring" open="true"><summary id="InvariantModels.Evaluate"><a class="docstring-binding" href="#InvariantModels.Evaluate"><code>InvariantModels.Evaluate</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Evaluate(M::MultiStep_Model, X, Index_List, Data, Encoded_Phase)</code></pre><p>Applies the polynomial representation of the model <code>M</code>, <code>X</code> to the data <code>Index_List, Data, Encoded_Phase</code> as if each data point was an initial condition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rsnumerics/InvariantModels.jl/blob/9ad165561d2f467e3161f454b25e89ab819413fc/src/MultiStep_Model.jl#L727-L732">source</a></section></details></article><article><details class="docstring" open="true"><summary id="InvariantModels.Slice"><a class="docstring-binding" href="#InvariantModels.Slice"><code>InvariantModels.Slice</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Slice(MTF::Multi_Foliation{M,State_Dimension,Skew_Dimension}, XTF, Encoded_Slice) where {M,State_Dimension,Skew_Dimension}</code></pre><p>In case the system is parameter dependent, this function creates an autonomous slice when the encoded parameter is <code>Encoded_Slice</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rsnumerics/InvariantModels.jl/blob/9ad165561d2f467e3161f454b25e89ab819413fc/src/Multi_Foliation.jl#L184-L188">source</a></section></details></article><article><details class="docstring" open="true"><summary id="InvariantModels.Model_From_ODE"><a class="docstring-binding" href="#InvariantModels.Model_From_ODE"><code>InvariantModels.Model_From_ODE</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Model_From_ODE(
    Vectorfield!,
    Forcing_Map!,
    Alpha_Map!,
    IC_Force,
    Parameters,
    dt,
    Time_Step;
    State_Dimension,
    Skew_Dimension,
    Start_Order,
    End_Order,
    Steady_State::Bool = true,
    Iterations = 100,
)</code></pre><p>Creates a discrete-time model from the vector field <code>Vectorfield!</code>, <code>Forcing_Map!</code> and <code>Alpha_Map!</code>. The definition is the same as in <a href="#InvariantModels.Generate_From_ODE"><code>Generate_From_ODE</code></a>. The routine first calculates a steady state of the system straight from the ODE. Then it create a polynomial map about the steady state. The resulting map has its steady state at the origin.</p><ul><li><code>dt</code> time step of the ODE solver</li><li><code>Time_Step</code> integration time of the ODE. One iteration of the resulting map is the same as solveing the ODE for <code>Time_Step</code> time.</li><li><code>State_Dimension</code> state space dimension</li><li><code>Skew_Dimension</code> forcing space dimension</li><li><code>Start_Order</code> starting order of the resulting map</li><li><code>End_Order</code> highest order monomial in the resulting map</li><li><code>Iterations</code> how many Newto iteration to take when solving for the steady state.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rsnumerics/InvariantModels.jl/blob/9ad165561d2f467e3161f454b25e89ab819413fc/src/MultiStep_Model.jl#L1923-L1953">source</a></section></details></article><article><details class="docstring" open="true"><summary id="InvariantModels.Model_From_Function_Alpha"><a class="docstring-binding" href="#InvariantModels.Model_From_Function_Alpha"><code>InvariantModels.Model_From_Function_Alpha</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Model_From_Function_Alpha(
    Vectorfield!,
    Alpha_Generator,
    Parameters;
    State_Dimension,
    Start_Order,
    End_Order
)</code></pre><p>Create a polynomial vector field by Taylor expanding the ODE given by <code>Vectorfield!</code> and <code>Alpha_Generator</code>.</p><p>It uses the same definition a a vector field as <a href="#InvariantModels.Generate_From_ODE"><code>Generate_From_ODE</code></a>. The difference is that <code>Alpha_Generator</code> is the infinitesimal generator matrix of the forcing dynamics.</p><p><code>Start_Order</code> and <code>End_Order</code> set the representing polynomial orders.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rsnumerics/InvariantModels.jl/blob/9ad165561d2f467e3161f454b25e89ab819413fc/src/MultiStep_Model.jl#L1624-L1641">source</a></section></details></article><h3 id="Representing-invariant-foliations"><a class="docs-heading-anchor" href="#Representing-invariant-foliations">Representing invariant foliations</a><a id="Representing-invariant-foliations-1"></a><a class="docs-heading-anchor-permalink" href="#Representing-invariant-foliations" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="InvariantModels.Scaling_Type"><a class="docstring-binding" href="#InvariantModels.Scaling_Type"><code>InvariantModels.Scaling_Type</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">@enum Scaling_Type begin
    No_Scaling = 0
    Linear_Scaling = 1
    Quadratic_Scaling = 2
end</code></pre><p>Describes how to scale the loss function as a function of the distance from the steady state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rsnumerics/InvariantModels.jl/blob/9ad165561d2f467e3161f454b25e89ab819413fc/src/Multi_Foliation.jl#L18-L26">source</a></section></details></article><article><details class="docstring" open="true"><summary id="InvariantModels.Make_Similar"><a class="docstring-binding" href="#InvariantModels.Make_Similar"><code>InvariantModels.Make_Similar</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Make_Similar(
    MTF::Multi_Foliation{M,State_Dimension,Skew_Dimension},
    XTF,
    New_Trajectories::Integer,
) where {M,State_Dimension,Skew_Dimension}</code></pre><p>Creates a new <code>Multi_Foliation</code> except that it will now have space for <code>New_Trajectories</code> initial conditions for the conjugate dynamics. This is used to create a model to evaluate testing data that has different number of trajectories than the training data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rsnumerics/InvariantModels.jl/blob/9ad165561d2f467e3161f454b25e89ab819413fc/src/Multi_Foliation.jl#L125-L134">source</a></section></details></article><article><details class="docstring" open="true"><summary id="InvariantModels.Multi_Foliation_Problem"><a class="docstring-binding" href="#InvariantModels.Multi_Foliation_Problem"><code>InvariantModels.Multi_Foliation_Problem</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Multi_Foliation_Problem(
    Index_List,
    Data_Decomposed,
    Encoded_Phase;
    Selection::NTuple{M, Vector{Int}},
    Model_Orders::NTuple{M, Int},
    Encoder_Orders::NTuple{M, Int},
    Unreduced_Model,
    Reduced_Model,
    Reduced_Encoder,
    SH,
    Initial_Iterations = 32,
    Scaling_Parameter = 2^(-4),
    Initial_Scaling_Parameter = 2^(-4),
    Scaling_Order = Linear_Scaling,
    node_ratio = 0.8,
    leaf_ratio = 0.8,
    max_rank = 48,
    Linear_Type::NTuple{M, Encoder_Linear_Type} = ntuple(i -&gt; Encoder_Array_Stiefel, M),
    Nonlinear_Type::NTuple{M, Encoder_Nonlinear_Type} = ntuple(i -&gt; Encoder_Compressed_Latent_Linear, M),
    Name = &quot;MTF-output&quot;,
    Time_Step = 1.0,
) where {M}</code></pre><p>Creates an object with multiple foliations that can be fitted to the data.</p><ul><li><code>Index_List</code>, <code>Data_Decomposed</code> and <code>Encoded_Phase</code> The training data approximately in the cooredinates of the invariant vector bundles   of the linear part of the system about the steady state.   This transformation can be achieved by <a href="#InvariantModels.Decompose_Data"><code>Decompose_Data</code></a>   and the decomposition can be obtained by <a href="#InvariantModels.Create_Linear_Decomposition"><code>Create_Linear_Decomposition</code></a>,   which in turn is obtained by an initial linear approximation of the model using <a href="#InvariantModels.Estimate_Linear_Model"><code>Estimate_Linear_Model</code></a>.</li><li><code>Selection</code> sets the vector bundles to be included in the calculated foliations.</li><li><code>Model_Orders</code> the polynomial orders of the conjugate maps for each foliation</li><li><code>Encoder_Orders</code> the polynomial orders of the conjugate maps for each foliation</li><li><code>Unreduced_Model</code> approximate linear model in the coordinate system of the data</li><li><code>Reduced_Model</code> approximate (autonomous) linear model in the coordinate system of <code>Reduced_Encoder</code></li><li><code>Reduced_Encoder</code> a linear encoder that reduces the approximate linear map <code>Unreduced_Model</code> to an autonomous map.   It can also be an identity, in which case the <code>Reduced_Model</code> and the <code>Unreduced_Model</code> are the same</li><li><code>SH</code> The forcing map, identified by <a href="#InvariantModels.Estimate_Linear_Model"><code>Estimate_Linear_Model</code></a></li><li><code>Initial_Iterations</code> how many optimisation steps to take to refine the supplied linear model to the encoded data</li><li><code>Scaling_Parameter</code> the parameter the specifies data scaling</li><li><code>Initial_Scaling_Parameter</code> the parameter the specifies data scaling at the initial refinement of the model.   Choosing it too small might result in diverging calculations.</li><li><code>Scaling_Order</code> whether to assign different important to various data points. This is must be one element of <a href="#InvariantModels.Scaling_Type"><code>Scaling_Type</code></a></li><li><code>node_ratio</code> when calculating the rank of a component in the compressed tensor representation,   by what ratio should we reduced the rank of the connecting parent node.</li><li><code>leaf_ratio</code> by how much are we allowed to reduce the rank of a leaf node from the dimeneionality of the tensor</li><li><code>max_rank</code> the maximum rank of any node in the compressed tensor representation</li><li><code>Linear_Type</code> this is a tuple that contains what restriction should apply to the linear part of the encoder.   The values are taken from <a href="#InvariantModels.Encoder_Linear_Type"><code>Encoder_Linear_Type</code></a></li><li><code>Nonlinear_Type</code> this is a tuple that contains what restriction should apply to the nonlinear part of the encoder.   The values are taken from <a href="#InvariantModels.Encoder_Nonlinear_Type"><code>Encoder_Nonlinear_Type</code></a></li><li><code>Name</code> this string variabel is used for the name of the data file wher the foliation is periodically save to.</li><li><code>Time_Step</code> the sampling time step of the supplied data. This is used only to display frequency information during calulation,   otherwise has no effect.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rsnumerics/InvariantModels.jl/blob/9ad165561d2f467e3161f454b25e89ab819413fc/src/Multi_Foliation_Problem.jl#L14-L70">source</a></section></details></article><article><details class="docstring" open="true"><summary id="InvariantModels.Multi_Foliation_Test_Problem"><a class="docstring-binding" href="#InvariantModels.Multi_Foliation_Test_Problem"><code>InvariantModels.Multi_Foliation_Test_Problem</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Multi_Foliation_Test_Problem(
    MTFP::Multi_Foliation_Problem{M,State_Dimension,Skew_Dimension},
    Index_List,
    Data_Decomposed,
    Encoded_Phase;
    Initial_Scaling_Parameter = 2^(-4),
) where {M,State_Dimension,Skew_Dimension}</code></pre><p>This creates a test problem with test data included. The test data in <code>Index_List</code>, <code>Data_Decomposed</code> and <code>Encoded_Phase</code>. <code>MTFP</code> is a <a href="#InvariantModels.Multi_Foliation_Problem"><code>Multi_Foliation_Problem</code></a>. <code>Initial_Scaling_Parameter</code> has the same meaning as in <a href="#InvariantModels.Multi_Foliation_Problem"><code>Multi_Foliation_Problem</code></a> but applied to the testing data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rsnumerics/InvariantModels.jl/blob/9ad165561d2f467e3161f454b25e89ab819413fc/src/Multi_Foliation_Problem.jl#L173-L185">source</a></section></details></article><article><details class="docstring" open="true"><summary id="InvariantModels.Optimise!"><a class="docstring-binding" href="#InvariantModels.Optimise!"><code>InvariantModels.Optimise!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Optimise!(
    MTFP::Multi_Foliation_Problem{M,State_Dimension,Skew_Dimension},
    MTFP_Test::Union{Nothing,Multi_Foliation_Problem{M,State_Dimension,Skew_Dimension}} = nothing;
    Model_Iterations = 16,
    Encoder_Iterations = 8,
    Steps = 128,
    Gradient_Ratio = 2^(-7),
    Gradient_Stop = 2^(-29),
    Picks = [Complete_Component_Index(MTFP.XTF.x[k].x[2], (1,)) for k = 1:M],
) where {M,State_Dimension,Skew_Dimension}</code></pre><p>Fits the set of foliations defined in <code>MTFP</code> to the given data.</p><ul><li><code>MTFP</code>      a <a href="#InvariantModels.Multi_Foliation_Problem"><code>Multi_Foliation_Problem</code></a></li><li><code>MTFP_Test</code> a <a href="#InvariantModels.Multi_Foliation_Test_Problem"><code>Multi_Foliation_Test_Problem</code></a>.   The parameters of <code>MTFP_Test</code> are regularly synchronised with <code>MTFP</code>,   except the initial condition of the latent model, which are fitted from the testing trajectories.</li><li><code>Model_Iterations</code> maximum number of optimisation steps taken when the conjugate dynamics is fitted to latent data.   The optimisation is a version of the Levenberg-Marquardt method.</li><li><code>Encoder_Iterations</code> maximum number of optimisation steps for any component of the encoder. The optimisation technique is a manifold Newton trust region method.</li><li><code>Steps</code> the number of optimisation cycles for each foliation.</li><li><code>Gradient_Ratio</code> Optimisation of a component stops when the norm of the gradient has reduced by this factor</li><li><code>Gradient_Stop</code> Optimisation of a component stops when the norm of the gradient has reached this value</li><li><code>Picks</code> Used for testing the code, leave as is.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rsnumerics/InvariantModels.jl/blob/9ad165561d2f467e3161f454b25e89ab819413fc/src/Multi_Foliation_Problem.jl#L224-L248">source</a></section></details></article><h3 id="Analysing-invariant-foliations"><a class="docs-heading-anchor" href="#Analysing-invariant-foliations">Analysing invariant foliations</a><a id="Analysing-invariant-foliations-1"></a><a class="docs-heading-anchor-permalink" href="#Analysing-invariant-foliations" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="InvariantModels.Find_DATA_Manifold"><a class="docstring-binding" href="#InvariantModels.Find_DATA_Manifold"><code>InvariantModels.Find_DATA_Manifold</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Find_DATA_Manifold(MTF::Multi_Foliation{M,State_Dimension,Skew_Dimension}, XTF, SH, Index;
    Radial_Order, Radial_Intervals, Radius,
    Phase_Dimension, Transformation,
    abstol=1e-9, reltol=1e-9, maxiters=12, initial_maxiters=200
) where {M,State_Dimension,Skew_Dimension}</code></pre><p>Calculates a two-dimensional invariant manifold from the set of invariant foliations <code>MTF</code>, <code>XTF</code>. The calulation is for the invariant foliation selected by <code>Index</code>. <code>SH</code> is the forcing map. The rest of the function arguments are the same as in <a href="#InvariantModels.Find_MAP_Manifold"><code>Find_MAP_Manifold</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rsnumerics/InvariantModels.jl/blob/9ad165561d2f467e3161f454b25e89ab819413fc/src/Polar_Manifold.jl#L844-L854">source</a></section></details></article><article><details class="docstring" open="true"><summary id="InvariantModels.Extract_Manifold_Embedding"><a class="docstring-binding" href="#InvariantModels.Extract_Manifold_Embedding"><code>InvariantModels.Extract_Manifold_Embedding</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Extract_Manifold_Embedding(
    MTF::Multi_Foliation{M,State_Dimension,Skew_Dimension},
    XTF,
    Index,
    Data_Decomp,
    Encoded_Phase;
    Radial_Order,
    Radial_Intervals,
    Radius,
    Phase_Dimension,
    Output_Transformation = [],
    Output_Inverse_Transformation = [],
    Output_Scale,
    abstol = 1e-9,
    reltol = 1e-9,
    maxiters = 24,
    initial_maxiters = 200,
)</code></pre><p>Extracts the invariant manifold from a set of invariant foliations <code>MTF</code>, <code>XTF</code>. The parametrisation of the foliation is the same as the identofied conjugate map. Therefore it is not directly useable to obtain backbone curves. The result is primarily used to find out the physical amplitude of an encoded data point that is mapped back onto the invariant manifold.</p><p>The input arguments are</p><ul><li><code>MTF</code>, <code>XTF</code> represent the set of invariant foliations previously fitted to data</li><li><code>Index</code> chooses the invariant foliation for which we calculate the invariant manifold</li><li><code>Radial_Order</code> order of the Chebyshev in the radial direction</li><li><code>Radial_Intervals</code> number of polynomials in the radial direction</li><li><code>Radius</code> the maximum radius to calculate the invariant manifold for</li><li><code>Phase_Dimension</code> the number of Fourier collocation points to use in the angular direction</li><li><code>Output_Transformation</code> same as <code>Data_Encoder</code> produced by <a href="#InvariantModels.Create_Linear_Decomposition"><code>Create_Linear_Decomposition</code></a>.</li><li><code>Output_Inverse_Transformation</code> same as <code>Data_Decoder</code> produced by <a href="#InvariantModels.Create_Linear_Decomposition"><code>Create_Linear_Decomposition</code></a>.   Note that only one of <code>Output_Transformation</code> or <code>Output_Inverse_Transformation</code> need to be specified.   If <code>Output_Inverse_Transformation</code> is specified, it takes precedence.</li><li><code>Output_Scale</code> same as <code>Data_Scale</code> produced by <a href="#InvariantModels.Decomposed_Data_Scaling"><code>Decomposed_Data_Scaling</code></a></li><li><code>abstol = 1e-9</code> absolute tolerance when solving the invariance equation</li><li><code>reltol = 1e-9</code> relative tolerance when solving the invariance equation</li><li><code>maxiters = 12</code> number of solution steps when calculating each segment of the manifold</li><li><code>initial_maxiters</code> the maximum iteration when calculating the segment containing the steady state.   About the steady state the manifold is non-hyperbolic and therefore numerically challenging to calculate.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rsnumerics/InvariantModels.jl/blob/9ad165561d2f467e3161f454b25e89ab819413fc/src/Polar_Implicit_Manifold.jl#L520-L562">source</a></section></details></article><article><details class="docstring" open="true"><summary id="InvariantModels.Data_Result"><a class="docstring-binding" href="#InvariantModels.Data_Result"><code>InvariantModels.Data_Result</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Data_Result(
PM::Polar_Manifold{
    State_Dimension,
    Latent_Dimension,
    Radial_Order,
    Radial_Dimension,
    Phase_Dimension,
    Skew_Dimension,
},
PX,
MIP,
XIP,
MTF::Multi_Foliation,
XTF,
Index,
Index_List,
Data,
Encoded_Phase;
Time_Step = 1.0,
Transformation = PM.Transformation,
Slice_Transformation = Transformation,
Hz = false,
Damping_By_Derivative::Bool = true,
Model_IC = false,</code></pre><p>) where {     State<em>Dimension,     Latent</em>Dimension,     Radial<em>Order,     Radial</em>Dimension,     Phase<em>Dimension,     Skew</em>Dimension, }</p><p>Plots the instantaneous frequency and damping curves for the invariant foliation at <code>Index</code>.</p><ul><li><code>PM</code>, <code>PX</code> the invariant manifold calculated by <a href="#InvariantModels.Find_DATA_Manifold"><code>Find_DATA_Manifold</code></a></li><li><code>MIP</code>, <code>XIP</code> the manifold embedding calculated by <a href="#InvariantModels.Extract_Manifold_Embedding"><code>Extract_Manifold_Embedding</code></a></li><li><code>MTF</code>, <code>XTF</code> the set of invariant foliations</li><li><code>Index</code> which invariant foliation is it calculated for</li><li><code>Index_List</code>, <code>Data</code>, <code>Encoded_Phase</code> the training data</li><li><code>Time_Step</code> sampling time-step of data for calulating frequencies</li><li><code>Transformation</code> the transformation the brings back the data to the physical coordinate</li><li><code>Slice_Transformation</code> the transformation, in case <code>PM</code>, <code>PX</code> are calculated from a fixed parameters slice of the identified foliation.   If not a slice, should be the same as <code>Transformation</code>.</li><li><code>Hz</code> if <code>true</code> frequency is displayed in Hz, otherwise it is rad/s.</li><li><code>Damping_By_Derivative</code> if <code>true</code> a truely instantaneous damping ratio is displayed.   If <code>false</code> the damping ratio commonly (and mistakenly) used in the literature is displayed</li><li><code>Model_IC</code> whether to re-calculate the initial conditions of trajectories stored in <code>XTF</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rsnumerics/InvariantModels.jl/blob/9ad165561d2f467e3161f454b25e89ab819413fc/src/Polar_Manifold.jl#L1182-L1230">source</a></section></details></article><article><details class="docstring" open="true"><summary id="InvariantModels.Data_Error"><a class="docstring-binding" href="#InvariantModels.Data_Error"><code>InvariantModels.Data_Error</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Data_Error(
PM::Polar_Manifold{
    State_Dimension,
    Latent_Dimension,
    Radial_Order,
    Radial_Dimension,
    Phase_Dimension,
    Skew_Dimension,
},
PX,
MIP,
XIP,
MTF::Multi_Foliation,
XTF,
Index,
Index_List,
Data,
Encoded_Phase;
Transformation,
Model_IC = false,
Iterations = 32,</code></pre><p>) where {     State<em>Dimension,     Latent</em>Dimension,     Radial<em>Order,     Radial</em>Dimension,     Phase<em>Dimension,     Skew</em>Dimension, }     )</p><p>Plots the training and testing errors as a function of vibration amplitude.</p><ul><li><code>PM</code>, <code>PX</code> the invariant manifold calculated by <a href="#InvariantModels.Find_DATA_Manifold"><code>Find_DATA_Manifold</code></a></li><li><code>MIP</code>, <code>XIP</code> the manifold embedding calculated by <a href="#InvariantModels.Extract_Manifold_Embedding"><code>Extract_Manifold_Embedding</code></a></li><li><code>MTF</code>, <code>XTF</code> the set of invariant foliations</li><li><code>Index</code> which invariant foliation is it calculated for</li><li><code>Index_List</code>, <code>Data</code>, <code>Encoded_Phase</code> the training data</li><li><code>Transformation</code> the transformation the brings back the data to the physical coordinate</li><li><code>Color</code> line colour of the plot</li><li><code>Model_IC</code> whether to re-calculate the initial conditions of trajectories stored in <code>XTF</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rsnumerics/InvariantModels.jl/blob/9ad165561d2f467e3161f454b25e89ab819413fc/src/Polar_Manifold.jl#L1050-L1091">source</a></section></details></article><h3 id="Calculating-invariant-manifolds-from-ODEs-and-maps"><a class="docs-heading-anchor" href="#Calculating-invariant-manifolds-from-ODEs-and-maps">Calculating invariant manifolds from ODEs and maps</a><a id="Calculating-invariant-manifolds-from-ODEs-and-maps-1"></a><a class="docs-heading-anchor-permalink" href="#Calculating-invariant-manifolds-from-ODEs-and-maps" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="InvariantModels.Find_ODE_Manifold"><a class="docstring-binding" href="#InvariantModels.Find_ODE_Manifold"><code>InvariantModels.Find_ODE_Manifold</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Find_ODE_Manifold(
    MM::MultiStep_Model,
    MX,
    Generator,
    Select;
    Radial_Order,
    Radial_Intervals,
    Radius,
    Phase_Dimension,
    abstol = 1e-9,
    reltol = 1e-9,
    maxiters = 12,
    initial_maxiters = 200,
)</code></pre><p>Calculates a two-dimensional invariant manifold from the ODE <code>MM</code>, <code>MX</code>. The result is stored as a piecewise Chebyshev polynomial in the radial direction Fourier collocation in the angular direction.</p><p>The input arguments are</p><ul><li><code>MM</code> and <code>MX</code> represent the polynomial vector field</li><li><code>Generator</code> is the infinitesimal generator matrix of the forcing dynamics</li><li><code>Select</code> chooses along which vector bundle to calculate the invariant manifold</li><li><code>Radial_Order</code> order of the Chebyshev in the radial direction</li><li><code>Radial_Intervals</code> number of polynomials in the radial direction</li><li><code>Radius</code> the maximum radius to calculate the invariant manifold for</li><li><code>Phase_Dimension</code> the number of Fourier collocation points to use in the angular direction</li><li><code>abstol = 1e-9</code> absolute tolerance when solving the invariance equation</li><li><code>reltol = 1e-9</code> relative tolerance when solving the invariance equation</li><li><code>maxiters = 12</code> number of solution steps when calculating each segment of the manifold</li><li><code>initial_maxiters</code> the maximum iteration when calculating the segment containing the steady state.   About the steady state the manifold is non-hyperbolic and therefore numerically challenging to calculate.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rsnumerics/InvariantModels.jl/blob/9ad165561d2f467e3161f454b25e89ab819413fc/src/Polar_ODE_Manifold.jl#L433-L465">source</a></section></details></article><article><details class="docstring" open="true"><summary id="InvariantModels.Find_MAP_Manifold"><a class="docstring-binding" href="#InvariantModels.Find_MAP_Manifold"><code>InvariantModels.Find_MAP_Manifold</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Find_MAP_Manifold(
    MM::MultiStep_Model{State_Dimension,Skew_Dimension,Start_Order,End_Order,Trajectories},
    MX,
    Select;
    Radial_Order,
    Radial_Intervals,
    Radius,
    Phase_Dimension,
    abstol = 1e-9,
    reltol = 1e-9,
    maxiters = 12,
    initial_maxiters = 200,
) where {State_Dimension,Skew_Dimension,Start_Order,End_Order,Trajectories}</code></pre><p>Calculates a two-dimensional invariant manifold from the map <code>MM</code>, <code>MX</code>. The result is stored as a piecewise Chebyshev polynomial in the radial direction Fourier collocation in the angular direction.</p><p>The input arguments are</p><ul><li><code>MM</code> and <code>MX</code> are the discrete-time map</li><li><code>Select</code> chooses along which vector bundle to calculate the invariant manifold</li><li><code>Radial_Order</code> order of the Chebyshev in the radial direction</li><li><code>Radial_Intervals</code> number of polynomials in the radial direction</li><li><code>Radius</code> the maximum radius to calculate the invariant manifold for</li><li><code>Phase_Dimension</code> the number of Fourier collocation points to use in the angular direction</li><li><code>abstol = 1e-9</code> absolute tolerance when solving the invariance equation</li><li><code>reltol = 1e-9</code> relative tolerance when solving the invariance equation</li><li><code>maxiters = 12</code> number of solution steps when calculating each segment of the manifold</li><li><code>initial_maxiters</code> the maximum iteration when calculating the segment containing the steady state.   About the steady state the manifold is non-hyperbolic and therefore numerically challenging to calculate.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rsnumerics/InvariantModels.jl/blob/9ad165561d2f467e3161f454b25e89ab819413fc/src/Polar_Manifold.jl#L755-L785">source</a></section></details></article><article><details class="docstring" open="true"><summary id="InvariantModels.Model_Result"><a class="docstring-binding" href="#InvariantModels.Model_Result"><code>InvariantModels.Model_Result</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Model_Result(
    PM::Polar_Manifold,
    PX;
    Time_Step = 1.0,
    Hz = false,
    Damping_By_Derivative::Bool = true,
)</code></pre><p>Calculates the instantaneous frequency and damping ratio for the invariant manifold directly calculated from an ODE or map model.</p><ul><li><code>PM</code>, <code>PX</code> the invariant manifold calculated by <a href="#InvariantModels.Find_ODE_Manifold"><code>Find_ODE_Manifold</code></a> or <a href="#InvariantModels.Find_MAP_Manifold"><code>Find_MAP_Manifold</code></a></li><li><code>Time_Step</code> sampling time-step of data for calulating frequencies</li><li><code>Hz</code> if <code>true</code> frequency is displayed in Hz, otherwise it is rad/s.</li><li><code>Damping_By_Derivative</code> if <code>true</code> a truely instantaneous damping ratio is displayed.   If <code>false</code> the damping ratio commonly (and mistakenly) used in the literature is displayed</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rsnumerics/InvariantModels.jl/blob/9ad165561d2f467e3161f454b25e89ab819413fc/src/Polar_Manifold.jl#L1296-L1311">source</a></section></details></article><h3 id="Plotting-results"><a class="docs-heading-anchor" href="#Plotting-results">Plotting results</a><a id="Plotting-results-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting-results" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="InvariantModels.Create_Plot"><a class="docstring-binding" href="#InvariantModels.Create_Plot"><code>InvariantModels.Create_Plot</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Create_Plot(; Amplitude = &quot;Amplitude&quot;)</code></pre><p>Creates a figure to display the results.</p><ul><li>Amplitude is a string that will be put on the vertical axes of the plot</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rsnumerics/InvariantModels.jl/blob/9ad165561d2f467e3161f454b25e89ab819413fc/src/Polar_Manifold.jl#L1345-L1350">source</a></section></details></article><article><details class="docstring" open="true"><summary id="InvariantModels.Plot_Error_Curves!"><a class="docstring-binding" href="#InvariantModels.Plot_Error_Curves!"><code>InvariantModels.Plot_Error_Curves!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Plot_Error_Curves!(
    fig, Error_Curves, Data_Max_Pre;
    Color = Makie.wong_colors()[2],
    Dense_Style = :solid,
    Max_Style = :dot,
    Mean_Style = :solid,
    Amplitude_Scale = 1,
)</code></pre><ul><li><code>fig</code> is the figure to plot</li><li><code>Error_Curves</code> produced by <a href="#InvariantModels.Data_Error"><code>Data_Error</code></a></li><li><code>Data_Max_Pre</code> the maximum amplitude to consider</li><li><code>Color</code> line colour</li><li><code>Dense_Style</code> line style for density</li><li><code>Max_Style</code> line style for maximum error</li><li><code>Mean_Style</code> line style for mean error</li><li><code>Amplitude_Scale</code> a scaling factor for amplitudes. This can be use because the result is in different units.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rsnumerics/InvariantModels.jl/blob/9ad165561d2f467e3161f454b25e89ab819413fc/src/Polar_Manifold.jl#L1567-L1585">source</a></section></details></article><article><details class="docstring" open="true"><summary id="InvariantModels.Plot_Error_Trace"><a class="docstring-binding" href="#InvariantModels.Plot_Error_Trace"><code>InvariantModels.Plot_Error_Trace</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Plot_Error_Trace(
    fig,
    Index,
    Train_Trace,
    Test_Trace = nothing;
    Train_Color = Makie.wong_colors()[1],
    Test_Color = Makie.wong_colors()[2],
)</code></pre><p>Adds the training and testing errors to the figure <code>fig</code> for the foliation selected by <code>Index</code>. <code>Train_Trace</code> and <code>Test_Trace</code> are produced by <a href="#InvariantModels.Optimise!"><code>Optimise!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rsnumerics/InvariantModels.jl/blob/9ad165561d2f467e3161f454b25e89ab819413fc/src/Polar_Manifold.jl#L1412-L1424">source</a></section></details></article><article><details class="docstring" open="true"><summary id="InvariantModels.Annotate_Plot!"><a class="docstring-binding" href="#InvariantModels.Annotate_Plot!"><code>InvariantModels.Annotate_Plot!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Annotate_Plot!(fig)</code></pre><p>Perform the final annotation of the figure, so that it is ready for display.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rsnumerics/InvariantModels.jl/blob/9ad165561d2f467e3161f454b25e89ab819413fc/src/Polar_Manifold.jl#L1383-L1387">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="Tutorial/">Tutorial »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Sunday 14 December 2025 16:06">Sunday 14 December 2025</span>. Using Julia version 1.12.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

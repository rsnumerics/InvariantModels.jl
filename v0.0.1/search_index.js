var documenterSearchIndex = {"docs":
[{"location":"Tutorial/#A-simple-autonomous-system","page":"Tutorial","title":"A simple autonomous system","text":"","category":"section"},{"location":"Tutorial/#Identifying-the-invariant-foliations","page":"Tutorial","title":"Identifying the invariant foliations","text":"This tutorial goes through the steps of\n\nHow to produce training and test data from a differential equation\nHow to process the data so that it is suitable for finding invariant foliations\nHow to fit invariant foliations to data\nHow to calculate invariant manifolds from differential equations and discrete-time maps\nHow to extract invariant manifolds from the identified invariant foliations\nHow to assess the quality of obtained mathematical model\n\nThe differential equations is\n\ndotboldsymbolx = boldsymbolT^-1 boldsymbolf(boldsymbolT boldsymbolx)\n\nwhere \n\nboldsymbolf(boldsymbolx) = \n               beginpmatrix\n                   -alpha  x_1+left(x_1^2+x_2^2right) left(beta  x_1+delta  x_2right)+x_2 \n                   -alpha x_2+left(x_1^2+x_2^2right) left(beta  x_2-delta  x_1right)-x_1 \n                   -2 alpha  x_3\n                endpmatrix\n\nThe equation is selected to be nonlinear, but easy to investigate, so that the automatic test code runs quickly on slow hardware. Challenging problems can be found in the Examples folder.\n\nImporting packages\n\nusing LinearAlgebra\nusing Tullio\nusing JLSO\nusing Random\nusing StaticArrays\nusing InvariantModels\nusing CairoMakie","category":"section"},{"location":"Tutorial/#Creating-data-by-solving-a-differential-equation","page":"Tutorial","title":"Creating data by solving a differential equation","text":"Setting up the differential equations.\n\nODE_Transformation = SMatrix{3,3}(0.180047, 0.914719, -0.361763, 0.337552, -0.402896, -0.850725, -0.923927, 0.0310566, -0.381306)\n\nfunction Tutorial_VF!(dx, x, u, Parameters)\n    Alpha = Parameters.Alpha\n    Beta = Parameters.Beta\n    Delta = Parameters.Delta\n    \n    z = ODE_Transformation * x\n    dz = SVector(\n        -Alpha*z[1] + z[2] + (Beta*z[1] + Delta*z[2])*(z[1]^2 + z[2]^2),\n        -z[1] - Alpha*z[2] + (-Delta*z[1] + Beta*z[2])*(z[1]^2 + z[2]^2),\n        -2*Alpha*z[3],\n        )\n    dx .= transpose(ODE_Transformation) * dz\n    \n    return dx\nend\n\n# no forcing\nfunction Tutorial_Forcing!(u, Alpha, Parameters)\n    return u\nend\n\nfunction Tutorial_Forcing_Matrix!(x, Parameters, t)\n    return Rigid_Rotation_Matrix!(x, [0], 0, t)\nend\n\nSetting up parameters, time steps, etc\n\nName = \"Tutorial\"\nSkew_Dimension = 1\nTraining_Trajectories = 1\nTesting_Trajectories = 1\nTrajectory_Length = 2400\n\nForcing_Grid = Fourier_Grid(Skew_Dimension)\nParameters = (Alpha = 0.005, Beta = 0.005, Delta = 0.1)\nTime_Step = 0.5\n\nIC_x_Train = [0; 0.8; 0.1;;]\nIC_x_Test = [0.6; 0.1; 0;;]\nIC_Alpha_Train = ones(Skew_Dimension, Training_Trajectories)\nIC_Alpha_Test = ones(Skew_Dimension, Testing_Trajectories)\nIC_Force = []\nnothing; #hide\n\nGenerating training and testing data. Documentation is at Generate_From_ODE.\n\nList_of_Data, List_of_Phases = Generate_From_ODE(\n    Tutorial_VF!,\n    Tutorial_Forcing!,\n    Tutorial_Forcing_Matrix!,\n    Parameters,\n    Time_Step,\n    IC_x_Train,\n    IC_Force,\n    IC_Alpha_Train,\n    ones(Int, Training_Trajectories) * Trajectory_Length,\n)\nList_of_Data_T, List_of_Phases_T = Generate_From_ODE(\n    Tutorial_VF!,\n    Tutorial_Forcing!,\n    Tutorial_Forcing_Matrix!,\n    Parameters,\n    Time_Step,\n    IC_x_Test,\n    IC_Force,\n    IC_Alpha_Test,\n    ones(Int, Testing_Trajectories) * Trajectory_Length,\n)\nnothing; #hide","category":"section"},{"location":"Tutorial/#Processing-the-data","page":"Tutorial","title":"Processing the data","text":"Chopping up the trajectories into 600 point long segments. There is a balance between short and long trajectory segments.  Longer segments increase accuracy, but tracking error over longer periods can make the calculation unstable. Documentation is at Chop_And_Stitch.\n\nIndex_List, Data, Encoded_Phase =\n    Chop_And_Stitch(List_of_Data, List_of_Phases; maxlen = 600)\nIndex_List_T, Data_T, Encoded_Phase_T =\n    Chop_And_Stitch(List_of_Data_T, List_of_Phases_T; maxlen = 600)\nnothing; #hide\n\nA linear model is identified from the data.  This model contains the steady state, the linear dynamics about the steady state, and the forcing dynamics SH. Documentation is at Estimate_Linear_Model.\n\nScaling = ones(size(Data, 2)) # 1 ./ ((2^-12) .+ sqrt.(sum(Data .^ 2, dims = 1)))\nSteady_State, Linear_Model, SH = Estimate_Linear_Model(\n    Index_List,\n    Data,\n    Encoded_Phase,\n    Scaling;\n    Iterations = 0,\n    Order = 1,\n)\nnothing; #hide\n\nIf the model is forced it can be a good idea to filter the linear model so that it does not contain the high frequency content of the noise. The foloowing line has no effect for autonomous systems, only included for completeness. Documentation is at Filter_Linear_Model.\n\n# filtering up to 2 harmonics\nLinear_Model_Filtered = Filter_Linear_Model(Linear_Model, Forcing_Grid, 1)\nnothing; #hide\n\nCalculating the invariant vector bundles of the linear model, using the eigenvalues and eigenvectors of the transfer operator, see Create_Linear_Decomposition.  This creates tranformations that will bring the data into a coordinate system where the linear model is approximately block diagonal.\n\nDecomp = Create_Linear_Decomposition(\n    Linear_Model_Filtered,\n    SH;\n    Time_Step = Time_Step,\n    Reduce = true,\n    Align = true,\n    By_Eigen = true,\n)\nnothing; #hide\n\nDecomposing the data into the coordinate system of the invariant vector bundles. Documentation is at Decompose_Data.\n\nData_Decomp, _ =\n    Decompose_Data(Index_List, Data, Encoded_Phase, Steady_State, SH, Decomp.Data_Encoder)\nData_Decomp_T, _ = \n    Decompose_Data(Index_List_T, Data_T, Encoded_Phase_T, Steady_State, SH, Decomp.Data_Encoder)\nnothing; #hide\n\nCreating a scaling operation that makes sure that all data points are withing the unit ball of the phase space and that the signal amplitudes for each vector bundle are balanced. Documentation is at Decomposed_Data_Scaling.\n\nData_Scale = Decomposed_Data_Scaling(Data_Decomp, Decomp.Bundles)\nData_Decomp .*= Data_Scale\nData_Decomp_T .*= Data_Scale\nnothing; #hide\n\nSaving the data, so that it can be used later on, when evaluating the accuracy of the identified invariant foliations.\n\nJLSO.save(\n    \"DATA-$(Name).bson\",\n    :Parameters => Parameters,\n    :Time_Step => Time_Step,\n    :Index_List => Index_List,\n    :Data_Decomp => Data_Decomp,\n    :Encoded_Phase => Encoded_Phase,\n    :Index_List_T => Index_List_T,\n    :Data_Decomp_T => Data_Decomp_T,\n    :Encoded_Phase_T => Encoded_Phase_T,\n    :Decomp => Decomp,\n    :Steady_State => Steady_State,\n    :Linear_Model => Linear_Model_Filtered,\n    :SH => SH,\n    :Data_Scale => Data_Scale,\n)\nnothing; #hide","category":"section"},{"location":"Tutorial/#Fitting-the-data-to-a-set-of-invariant-foliations","page":"Tutorial","title":"Fitting the data to a set of invariant foliations","text":"Setting up the data structures of the invariant foliation. Here we select to hyper-parameters of the functional representations of the encoders and conjugate maps.  We also select how the error should be scaled within the loss function as a function of signal amplitude. Documentation is at Multi_Foliation_Problem.\n\nMTFP = Multi_Foliation_Problem(\n    Index_List,\n    Data_Decomp,\n    Encoded_Phase,\n    Selection = ([1; 2], [3;]),\n    Model_Orders = (3, 1),\n    Encoder_Orders = (1, 1),\n    Unreduced_Model = Decomp.Unreduced_Model,\n    Reduced_Model = Decomp.Reduced_Model,\n    Reduced_Encoder = Decomp.Reduced_Encoder,\n    SH = SH,\n    Initial_Iterations = 32,\n    Scaling_Parameter = 2^(-2),\n    Initial_Scaling_Parameter = 2^(-2),\n    Scaling_Order = Linear_Scaling,\n    node_ratio = 0.8,\n    leaf_ratio = 1.0,\n    max_rank = 24,\n    Linear_Type = (Encoder_Array_Stiefel, Encoder_Array_Stiefel),\n    Nonlinear_Type = (Encoder_Dense_Latent_Linear, Encoder_Dense_Latent_Linear),\n    Name = \"MTF-$(Name)\",\n    Time_Step = Time_Step,\n)\nnothing; #hide\n\nSetting up the data structures for the testing data.  This is necessary, because MTFP includes estimates of initial conditions for latent trajectories, which are differentr for the testing data. The estimates of initial conditions for latent trajectories must be updated before calculating the testing error.  Documentation is at Multi_Foliation_Test_Problem.\n\nMTFP_Test = Multi_Foliation_Test_Problem(\n    MTFP,\n    Index_List_T,\n    Data_Decomp_T,\n    Encoded_Phase_T;\n    Initial_Scaling_Parameter = 2^(-2),\n)\nnothing; #hide\n\nFinally, we are fitting the invariant foliations to data. Documentation is at Optimise!.\n\nOptimise!(\n    MTFP,\n    MTFP_Test;\n    Model_Iterations = 16,\n    Encoder_Iterations = 8,\n    Steps = 12,\n    Gradient_Ratio = 2^(-7),\n    Gradient_Stop = 2^(-29),\n)\nnothing; #hide","category":"section"},{"location":"Tutorial/#Analysing-the-the-calculated-invariant-foliations","page":"Tutorial","title":"Analysing the the calculated invariant foliations","text":"Setting the index of the vector bundle for which the results are analysed\n\nIndex = 1\n\nLoading the data. Here it is not strictly necessary, because these are already in memory.  However, if a separate script is use to analyse the results, data and the results must be loaded.\n\ndata = JLSO.load(\"DATA-$(Name).bson\")\nParameters      = data[:Parameters]\nTime_Step       = data[:Time_Step]\nIndex_List      = data[:Index_List]\nData_Decomp     = data[:Data_Decomp]\nEncoded_Phase   = data[:Encoded_Phase]\nIndex_List_T    = data[:Index_List_T]\nData_Decomp_T   = data[:Data_Decomp_T]\nEncoded_Phase_T = data[:Encoded_Phase_T]\nDecomp          = data[:Decomp]\nSteady_State    = data[:Steady_State]\nLinear_Model    = data[:Linear_Model]\nSH              = data[:SH]\nData_Scale      = data[:Data_Scale]\n#\nData_Encoder      = Decomp.Data_Encoder\nData_Decoder      = Decomp.Data_Decoder\nState_Dimension   = size(Data_Decomp, 1)\nSkew_Dimension    = size(Encoded_Phase, 1)\nIC_Force = []\nnothing; #hide\n\nLoading the identified invariant foliations.\n\ndd = JLSO.load(\"MTF-$(Name).bson\")\nMTF = dd[:MTF]\nXTF = dd[:XTF]\nMTF_Test = dd[:Test_MTF]\nXTF_Test = dd[:Test_XTF]\nError_Trace = dd[:Train_Error_Trace]\nTest_Trace = dd[:Test_Error_Trace]\nnothing; #hide\n\nCreating a figure for plotting the results\n\nfig = Create_Plot()\nnothing; #hide","category":"section"},{"location":"Tutorial/#Calculating-the-invariant-manifold-from-the-differential-equation","page":"Tutorial","title":"Calculating the invariant manifold from the differential equation","text":"Creating a polynomial vector field to be analysed subsequently. Documentation is at Model_From_Function_Alpha.\n\nMM, MX, MD = Model_From_Function_Alpha(\n    Tutorial_VF!,\n    Tutorial_Forcing!,\n    p -> Rigid_Rotation_Generator([0], 0.0),\n    IC_Force,\n    Parameters;\n    State_Dimension = State_Dimension,\n    Start_Order = 0,\n    End_Order = 3,\n)\nnothing; #hide\n\nSetting the parameters of the invariant manifold representation. We use piecewise cubic polynomials in the radia direction and 11 Fourier collocation points in the angular direction. The maximum amplutude to calculate is Radius.\n\nRadius = 1.0\nRadial_Order = 2\nRadial_Intervals = 96\nPolar_Order = 11\n\nCalculating the invariant manifold from the vector field.  Documentation is at Find_ODE_Manifold.\n\nMP, XP = Find_ODE_Manifold(\n    MM, MX, MD,\n    [1;2];\n    Radial_Order = Radial_Order,\n    Radial_Intervals = Radial_Intervals,\n    Radius = Radius,\n    Phase_Dimension = Polar_Order,\n    abstol = 1e-9,\n    reltol = 1e-9,\n    maxiters = 32,\n    initial_maxiters = 200,\n)\n\nPlotting the backbone curves calculated from the vector field. Documentation is at Model_Result.\n\nODE_Backbone_Curves = Model_Result(MP, XP, Hz = false)","category":"section"},{"location":"Tutorial/#Calculating-the-invariant-manifold-from-the-discrete-time-map","page":"Tutorial","title":"Calculating the invariant manifold from the discrete-time map","text":"Creates a discrete-time model from the vector field.  This is done by Taylor expanding a differential equation solver using automatic differentiation. Documentation is at Model_From_ODE.\n\nMM, MX = Model_From_ODE(\n    Tutorial_VF!,\n    Tutorial_Forcing!,\n    Tutorial_Forcing_Matrix!,\n    IC_Force,\n    Parameters,\n    Time_Step / 512,\n    Time_Step,\n    State_Dimension = State_Dimension,\n    Skew_Dimension = Skew_Dimension,\n    Start_Order = 0,\n    End_Order = 5,\n    Steady_State = true,\n)\nnothing; #hide\n\nSetting the parameters of the invariant manifold representation.\n\nRadius = 1.0\nCheb_Order = 2\nCheb_Intervals = 96\nPolar_Order = 11\n\nCalculating the invariant manifold from the discrete-time map. Documentation is at Find_MAP_Manifold.\n\nPM, PX = Find_MAP_Manifold(\n    MM, MX,\n    [1;2];\n    Radial_Order = Cheb_Order,\n    Radial_Intervals = Cheb_Intervals,\n    Radius,\n    Phase_Dimension = Polar_Order,\n    abstol = 1e-9,\n    reltol = 1e-9,\n    maxiters = 32,\n    initial_maxiters = 200,\n)\n\nPlotting the backbone curves calculated from the discrete-time map. Documentation is at Model_Result.\n\nMAP_Backbone_Curves = Model_Result(\n    PM,\n    PX,\n    Time_Step = Time_Step,\n    Hz = false,\n    Damping_By_Derivative = true,\n)","category":"section"},{"location":"Tutorial/#Calculating-the-invariant-manifold-from-the-set-of-invariant-foliations","page":"Tutorial","title":"Calculating the invariant manifold from the set of invariant foliations","text":"Setting the parameters of the invariant manifold representation.\n\nRadius = 1.0\nCheb_Order = 2\nCheb_Intervals = 112\nPolar_Order = 17\n\nNumerically calculating the invariant manifold from the identified invariant foliations. At the same time a normal form of the conjugate dynamics is calculated numerically. Documentation is at Find_DATA_Manifold.\n\nPPM, PPX = Find_DATA_Manifold(\n    MTF,\n    XTF,\n    SH,\n    Index;\n    Radial_Order = Cheb_Order,\n    Radial_Intervals = Cheb_Intervals,\n    Radius = Radius,\n    Phase_Dimension = Polar_Order,\n    Transformation = Data_Decoder ./ reshape(Data_Scale, 1, 1, :),\n    abstol = 1e-9,\n    reltol = 1e-9,\n    maxiters = 36,\n    initial_maxiters = 200,\n)\n\nYet again, setting the parameters of the invariant manifold representation.\n\nRadius = 1.0\nCheb_Order = 2\nCheb_Intervals = 120\nPolar_Order = 17\n\nNumerically calculating the invariant manifold from the identified invariant foliations.  This has the same parametrisation as the invariant foliation and therefore can be used to reconstruct the invariant manifold from the encoded trajectories. Documentation is at Extract_Manifold_Embedding.\n\nMIP, XIP, Torus, E_WW_Full, Latent_Data, E_ENC, AA, Valid_Ind = Extract_Manifold_Embedding(\n    MTF, XTF, Index,\n    Data_Decomp,\n    Encoded_Phase;\n    Radial_Order = Cheb_Order,\n    Radial_Intervals = Cheb_Intervals,\n    Radius = Radius,\n    Phase_Dimension = Polar_Order,\n    Output_Transformation = Data_Encoder,\n    Output_Scale = vec(Data_Scale),\n    abstol = 1e-9,\n    reltol = 1e-9,\n    maxiters = 36,\n    initial_maxiters = 200,\n)\n\nPlotting the backbone curves calculated from the invariant foliations. Documentation is at Data_Result.\n\nMTF_Cache, DATA_Backbone, DATA_Error_Curves, Data_Max = Data_Result(\n    PPM,\n    PPX,\n    MIP,\n    XIP,\n    MTF,\n    XTF,\n    Index,\n    Index_List,\n    Data_Decomp,\n    Encoded_Phase,\n    Transformation = Data_Decoder ./ reshape(Data_Scale, 1, 1, :),\n    Time_Step = Time_Step,\n    Hz = false,\n    Damping_By_Derivative = true,\n)\nnothing; #hide\n\nPlotting the training and testing error as they vary with amplitude. Documentation is at Data_Error.\n\nMTF_Cache, Data_Max_TEST, TEST_Error_Curves = Data_Error(\n    PPM,\n    PPX,\n    MIP,\n    XIP,\n    MTF_Test,\n    XTF_Test,\n    Index,\n    Index_List_T,\n    Data_Decomp_T,\n    Encoded_Phase_T;\n    Transformation = Data_Decoder ./ reshape(Data_Scale, 1, 1, :),\n    Model_IC = true,\n)\nnothing; #hide\n\nPlotting the results of all previous calculations including the history of training and testing error values for each iteration of the optimisation method.\n\nPlot_Backbone_Curves!(fig, ODE_Backbone_Curves, Data_Max; Label = \"ODE\", Color = Makie.wong_colors()[2])\nPlot_Backbone_Curves!(fig, MAP_Backbone_Curves, Data_Max; Label = \"MAP\", Color = Makie.wong_colors()[3])\nPlot_Backbone_Curves!(fig, DATA_Backbone, Data_Max; Label = \"Data\", Color = Makie.wong_colors()[1])\nPlot_Error_Curves!(fig, DATA_Error_Curves, Data_Max; Color = Makie.wong_colors()[1])\nPlot_Error_Curves!(fig, TEST_Error_Curves, Data_Max; Color = Makie.wong_colors()[2])\nPlot_Error_Trace(fig, Index, Error_Trace, Test_Trace)\n\nAnnotate the final figure with necessary information.\n\nAnnotate_Plot!(fig)\nsave(\"FIGURE-FULL.svg\", fig) #hide\nnothing; #hide\n\n(Image: )","category":"section"},{"location":"Tutorial/#Evaluating-the-model-and-comparing-to-testing-data","page":"Tutorial","title":"Evaluating the model and comparing to testing data","text":"Plotting the encoded testing trajectory and the predicted testing trajectory in the latent space.  The green line is the difference between prediction and the unseen data.\n\nfig2 = Figure()\n\nLatent_Dimension = size(MTF_Cache.Parts[Index].Latent_Data, 1)\nRows = round(Int, sqrt(Latent_Dimension))\nX_Axis = range(0, step = Time_Step, length = size(Data_Decomp_T, 2))\nlet it = 0\n    let k = Index\n        for l = 1:size(MTF_Cache.Parts[k].Latent_Data, 1)\n            id = it + 1\n            ax = Makie.Axis(\n                fig2[1+div(it, Rows), 1+mod(it, Rows)],\n                xlabel = L\"$t$ [s]\",\n                ylabel = L\"z_{%$id}\",\n            )\n            lines!(\n                ax,\n                X_Axis,\n                MTF_Cache.Parts[k].Latent_Data[l, :],\n                color = Makie.wong_colors()[1],\n            )\n            lines!(\n                ax,\n                X_Axis,\n                MTF_Cache.Parts[k].Model_Cache.Values[l, :],\n                color = Makie.wong_colors()[2],\n            )\n            lines!(\n                ax,\n                X_Axis,\n                MTF_Cache.Parts[k].Latent_Data[l, :] -\n                MTF_Cache.Parts[k].Model_Cache.Values[l, :],\n                color = Makie.wong_colors()[3],\n            )\n            it += 1\n        end\n    end\nend\nsave(\"FIGURE-LATENT.svg\", fig2) #hide\nnothing; #hide\n\n(Image: )","category":"section"},{"location":"#Invariant-Models","page":"Home","title":"Invariant Models","text":"Documentation for InvariantModels.\n\nThe primary goal of this software package is to identify mathematical models from data.  The identified model can be forced, parameter dependent or autonomous. The mathematical structure of the identified model is a series of invariant foliations. To avoid overfitting the foliation representation can be adjusted.  In general, encoders are represented as compressed polynomials, while the underlying low-dimensional model is an ordinary multivariate polynomial.\n\nThe software calculates invariant manifolds in vector fields and maps using a direct numerical method. The invariance equation discretised using a mixed Fourier and piecewise-Chebyshev collocation scheme.  Then the discretised equations are solved using a similar method to pseude-archlength continuation, which employs a phase and arclength condition. This is much more accurate than using series expansions about the steady state and does not suffer from small radii of convergence.\n\nThere are extensive utilities to prepare data for model identification.  These include delay embedding and dynamic mode decomposition to find ideal delay embedding coordinates. Approximate linear models can be decomposed into invariant vector bundles to provide an optimal coordinate system for model identification.","category":"section"},{"location":"#Set-up","page":"Home","title":"Set-up","text":"The system to be identified is in the skew-product form\n\nbeginaligned\n    boldsymbolx_k+1 = boldsymbolf left(boldsymbolx_k boldsymboltheta right)\n    boldsymboltheta_k+1 = boldsymbolg( boldsymboltheta_k )\nendaligned tagMAP\n\nwhere boldsymbolfin Xtimes Yto X, boldsymbolgYto Y are functions defined on the d_X-dimensional linear space X and d_Y-dimensional differentiable manifold Y, respectively. The forcing map boldsymbolg is volume preserving, hence it has recurrent dynamics.\n\nEvery volume preserving map can be transformed into a coordinate system where its representation is approximately a unitary matrix.  To find the unitary matrix boldsymbolOmega we use the transformation\n\nboldsymbolalpha = boldsymbolPsi(boldsymboltheta)\n\nwhere boldsymbolPsi is a vector of linearly independent scalar valued functions. It is known that as the dimensionality of boldsymbolPsi increases, the volume preserving map boldsymbolg transforms into a linear unitary map boldsymbolOmega [KKS16], [KM17]. Another consequence of the transformation is that, when transformed, function boldsymbolf becomes linear in new variables boldsymbolalpha.\n\nAccordingly, system (MAP) is written in the form of\n\nbeginaligned\n    boldsymbolx_k+1 = boldsymbolF left(boldsymbolx_kright) boldsymbolalpha\n    boldsymbolalpha_k+1 = boldsymbolOmega boldsymbolalpha_k\nendaligned tagMAP-TR\n\nwhere boldsymbolx_k in mathbbR^n is the state variable, boldsymbolalpha in mathbbR^m is the encoded phase variable.","category":"section"},{"location":"#Data-representation","page":"Home","title":"Data representation","text":"The data is a set of N trajectories, each of which are ell_j-ell_j-1 points long for j=1ldotsN, where ell_0=0. In formulae the trajectories are \n\nbeginalign*\n    left(boldsymbolx_1boldsymbolalpha_1right)left(boldsymbolx_2boldsymbolalpha_2right)ldotsleft(boldsymbolx_ell_1boldsymbolalpha_ell_1right)  \n    vdots qquad qquad  \n    left(boldsymbolx_ell_N-1+1boldsymbolalpha_ell_N-1+1right)left(boldsymbolx_ell_N-1+2boldsymbolalpha_ell_N-1+2right)ldotsleft(boldsymbolx_ell_Nboldsymbolalpha_ell_Nright) \nendalign*\n\nHere boldsymbolalpha represent the state of the forcing dynamics as encoded by the boldsymbolPsi function. \n\nThe data is arranged into two arrays. The array Data is simply the state\n\nbeginpmatrix \n    boldsymbolx_1  boldsymbolx_2  cdots  boldsymbolx_ell_N\nendpmatrix\n\nThe second array Encoded_Phase contains the forcing states\n\nbeginpmatrix \n    boldsymbolalpha_1  boldsymbolalpha_2  cdots  boldsymbolalpha_ell_N\nendpmatrix\n\nTo make sure that the system know where each trajectory starts and ends, we also must supply the Index_List vector\n\nbeginpmatrix \n    ell_0  ell_1  cdots  ell_N\nendpmatrix","category":"section"},{"location":"#Why-invariant-foliations","page":"Home","title":"Why invariant foliations","text":"Invariant foliations are the only architecture that guarantees invariance and uniqueness (under some smoothness and non-resonance conditions) at the same time [Sza20, Sza23].\n\nAll dynamic model reduction architectures can be put into four categories.  Each architecture must contain functional connections between the model and the data.  This functional connection can only go two ways: from the data to the model or in reverse, which are the encoders and decoders, respectively.  One has to establish this connection both at the initial condition and at the model prediction. This is exactly four combinations.\n\nThere are four ways to connect a low-order model boldsymbolR to boldsymbolF. The figure below shows the four combinations. Only invariant foliations and invariant manifolds produce meaningful reduced order models. Only invariant foliations and autoencoders can be fitted to data. The intersection is invariant foliations.\n\n(Image: )\n\nTherefore,\n\nwhen a system of equations is given, invariant manifolds are the most appropriate (foliations are still possible),\nwhen data is given, only invariant foliations are appropriate.\n\nAutoencoders such as SSMLearn do not enforce invariance and therefore generate spurious results as shown in [Sza23].","category":"section"},{"location":"#Invariant-Foliations","page":"Home","title":"Invariant Foliations","text":"The sofware identifies the encoder boldsymbolU and the conjugate map boldsymbolR from the invariance equation\n\nboldsymbolRleft(boldsymbolUleft(boldsymbolxboldsymbolthetaright)boldsymbolthetaright) = boldsymbolUleft(boldsymbolfleft(boldsymbolxboldsymbolthetaright)boldsymbolgleft(boldsymbolthetaright)right) tagFOIL\n\nEquation (FOIL) is turned into a least squares optimisation problem and the loss function is minimised.","category":"section"},{"location":"#Invariant-Manifolds","page":"Home","title":"Invariant Manifolds","text":"The sofware also calculates invariant manifolds from maps and vector fields. The invariance for manifolds is\n\nboldsymbolSleft(boldsymbolVleft(boldsymbolxboldsymbolthetaright)boldsymbolthetaright) = boldsymbolVleft(boldsymbolfleft(boldsymbolxboldsymbolthetaright)boldsymbolgleft(boldsymbolthetaright)right) tagMAN\n\nwhere boldsymbolV is the decoder and boldsymbolS is the conjugate map. Since we are interested in oscilllatory dynamics on 2D manifolds, the invariance equation can be written in polar coordinates, that is\n\nboldsymbolVleft(Rleft(rhoright)Tleft(rhoright)boldsymbolgleft(boldsymbolthetaright)right)=boldsymbolfleft(boldsymbolVleft(rhobetaboldsymbolthetaright)boldsymbolthetaright)\n\nwhere R and T represent the conjugate dynamics. The parametrisation of the invariant manifold is fixed by the amplitude and phase conditions\n\nbeginaligned\n    int_Yint_0^2pileftlangle D_1boldsymbolVleft(rhobetaboldsymbolthetaright)boldsymbolVleft(rhobetaboldsymbolthetaright)-boldsymbolVleft(0betaboldsymbolthetaright)rightrangle mathrmdbetamathrmdboldsymboltheta = rho \n    int_Yint_0^2pileftlangle D_1boldsymbolVleft(rbetaboldsymbolthetaright)D_2boldsymbolVleft(rbetaboldsymbolthetaright)rightrangle mathrmdbetamathrmdboldsymboltheta = 0\nendaligned\n\nThe instantantaneous damping ratio and frequency are calculated as\n\nbeginaligned\nzetaleft(rhoright)\t=-fracfracmathrmdmathrmdrhoRleft(rhoright)Tleft(rhoright)textand\nomegaleft(rhoright)\t=Tleft(rhoright)\nendaligned\n\nrespectively.","category":"section"},{"location":"#References","page":"Home","title":"References","text":"S. Klus, P. Koltai and C. Schütte. On the numerical approximation of the Perron-Frobenius and Koopman operator. Journal of Computational Dynamics 3, 51–79 (2016).\n\n\n\nM. Korda and I. Mezić. On Convergence of Extended Dynamic Mode Decomposition to the Koopman Operator. Journal of Nonlinear Science 28, 687–710 (2017).\n\n\n\nR. Szalai. Invariant spectral foliations with applications to model order reduction and synthesis. Nonlinear Dynamics 101, 2645–2669 (2020).\n\n\n\nR. Szalai. Data-Driven Reduced Order Models Using Invariant Foliations, Manifolds and Autoencoders. Journal of Nonlinear Science 33, 75 (2023).\n\n\n\n","category":"section"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"#API","page":"Home","title":"API","text":"","category":"section"},{"location":"#Fourier-collocation","page":"Home","title":"Fourier collocation","text":"","category":"section"},{"location":"#One-dimensional-polynomial-collocation-and-interpolation","page":"Home","title":"One-dimensional polynomial collocation and interpolation","text":"","category":"section"},{"location":"#Data-pre-processing","page":"Home","title":"Data pre-processing","text":"","category":"section"},{"location":"#Generating-data-from-differential-equations","page":"Home","title":"Generating data from differential equations","text":"","category":"section"},{"location":"#Types-of-encoders","page":"Home","title":"Types of encoders","text":"","category":"section"},{"location":"#Multivariate-polynomial-models","page":"Home","title":"Multivariate polynomial models","text":"These models represent\n\nThe conjugate dynamics\na vector field\na nonlinear map produced from a vector field\n\nThe representation is used to fit full trajectories to data and therefore making it a highly nonlinear optimisation problem.","category":"section"},{"location":"#Representing-invariant-foliations","page":"Home","title":"Representing invariant foliations","text":"","category":"section"},{"location":"#Analysing-invariant-foliations","page":"Home","title":"Analysing invariant foliations","text":"","category":"section"},{"location":"#Calculating-invariant-manifolds-from-ODEs-and-maps","page":"Home","title":"Calculating invariant manifolds from ODEs and maps","text":"","category":"section"},{"location":"#Plotting-results","page":"Home","title":"Plotting results","text":"","category":"section"},{"location":"#InvariantModels.Fourier_Grid","page":"Home","title":"InvariantModels.Fourier_Grid","text":"Fourier_Grid(Phase_Dimension::Integer)\n\nCreates a uniform grid on the 0 2pi) interval.\n\n\n\n\n\n","category":"function"},{"location":"#InvariantModels.Fourier_Interpolate","page":"Home","title":"InvariantModels.Fourier_Interpolate","text":"Fourier_Interpolate(grid, theta::Number)\n\nEvaluates the set of Dirichlet kernels specific to the uniform grid at point theta. The result is a vector.\n\n\n\n\n\nFourier_Interpolate(grid, theta::AbstractArray{T,1}) where {T}\n\nEvaluates the set of Dirichlet kernels specific to the uniform grid at all points in theta. The result is a matrix, where each column corresponds to a value in theta.\n\n\n\n\n\n","category":"function"},{"location":"#InvariantModels.Rigid_Rotation_Matrix!","page":"Home","title":"InvariantModels.Rigid_Rotation_Matrix!","text":"Rigid_Rotation_Matrix!(Alpha_Matrix, Grid, Omega_ODE::Number, t::Number)\n\nCreates the fundamental solution matrix for the rigid rotation on the circle in the space of the uniform Grid on the circle. The angular speed of the rotation is Omega_ODE and the result is written into Alpha_Matrix. The indepedent variabe is t.\n\n\n\n\n\n","category":"function"},{"location":"#InvariantModels.Rigid_Rotation_Generator","page":"Home","title":"InvariantModels.Rigid_Rotation_Generator","text":"Rigid_Rotation_Generator(Grid, Omega_ODE::Number)\n\nThis is the infinitesimal generator of the rigid rotation with Omega_ODE angular speed.\n\n\n\n\n\n","category":"function"},{"location":"#InvariantModels.Chebyshev_Grid","page":"Home","title":"InvariantModels.Chebyshev_Grid","text":"Chebyshev_Grid(np::Integer)\n\nCreates a Chebyshev grid with np grid points.\n\nt_j = cosfrac(j-1) pi n-1 j =1ldotsn\n\n\n\n\n\nChebyshev_Grid(np::Integer, a::T, b::T) where {T<:Number}\n\nCreates a Chebyshev grid with np grid points within the interval a b.\n\nt_j = fraca+b2 + fraca-b2 cosfrac(j-1) pi n-1 j =1ldotsn\n\n\n\n\n\n","category":"function"},{"location":"#InvariantModels.Barycentric_Interpolation_Matrix","page":"Home","title":"InvariantModels.Barycentric_Interpolation_Matrix","text":"Barycentric_Interpolation_Matrix(t::AbstractVector, ti::AbstractVector)\n\nCreates a matrix that performs a polynomial interpolation from grid t to grid ti.\n\n\n\n\n\nBarycentric_Interpolation_Matrix(order::Integer, mesh::Vector, ti::AbstractVector)\n\nCreates a matrix that performs a polynomial interpolation from a mesh, where each interval has order number of Chebyshev points. The target points are in grid.\n\n\n\n\n\n","category":"function"},{"location":"#InvariantModels.Delay_Embed","page":"Home","title":"InvariantModels.Delay_Embed","text":"Delay_Embed(Signals, Phases; delay = 1, skip = 1, max_length = typemax(Int))\n\nCreates a delay embedding of Signals while limits trajectory length to max_length. The delay is delay long and only every skipth point along the trajectory is put into the delay embedded data. Phases are simply copied over to the output while making sure that signal lengths and phase length are the same, limited by max_length.\n\nThe return values Delay_Signals, Delay_Phases are matrices of appropriate sizes.\n\n\n\n\n\n","category":"function"},{"location":"#InvariantModels.Chop_And_Stitch","page":"Home","title":"InvariantModels.Chop_And_Stitch","text":"Chop_And_Stitch(Signals, Phases; maxlen = 1000)\n\nChops up Signals and Phases into chunks of maximum maxlen chuncks. Then concatenates the result into the arrays Index_List, Data, Encoded_Phase. The list Index_List tells, where each chunk starts and ends within the arrays Data and Encoded_Phase.\n\n\n\n\n\n","category":"function"},{"location":"#InvariantModels.Estimate_Linear_Model","page":"Home","title":"InvariantModels.Estimate_Linear_Model","text":"Estimate_Linear_Model(\n    Index_List,\n    Data,\n    Encoded_Phase,\n    Scaling;\n    Iterations = 0,\n    Order = 1,\n)\n\nGiven the data Index_List, Data, Encoded_Phase this function estimates a linear model, a steady state and a model of forcing.\n\nThe output is Steady_State, BB_Linear, SH. Steady_State is the steady state of the system, BB_Linear is the estimated linear model and SH is the unitary transformation representing forcing.\n\nWhen fitting the linear model Scaling attaches an importance to each data point. Iterations allows us to take into account the data as trajectories and use multi-step optimisation to find BB_Linear. A nonlinear model can also be fitted by making Order  1. When a nonlinear model is identified, its steady state is found by Newton's method and its Jacobian is calculated at the steady state, which is then returned as the linear model BB_Linear.\n\n\n\n\n\n","category":"function"},{"location":"#InvariantModels.Filter_Linear_Model","page":"Home","title":"InvariantModels.Filter_Linear_Model","text":"Filter_Linear_Model(BB, Grid, order)\n\nAssuming a uniform Fourier grid Grid, this function returns a truncated Fourier series of the linear model BB. This removes inaccurate higher frequency components of the approximate linear model before decomposing it into invariant vector bundles.\n\n\n\n\n\n","category":"function"},{"location":"#InvariantModels.Create_Linear_Decomposition","page":"Home","title":"InvariantModels.Create_Linear_Decomposition","text":"Create_Linear_Decomposition(\n    BB_Filtered,\n    SH;\n    Time_Step = 1.0,\n    Reduce = false,\n    Align = true,\n    By_Eigen = false,\n)\n\nCreates an invariant vector bundle decomposition of the linear system represented by BB_Filtered and the forcing dynamics SH. If Time_Step is specified, the fucntion also prints the estimated natural frequencies and damping ratios. The decomposition outputs vector bundles with orthonormal bases. Therefore the reduced model will be block-diagonal (with at most 2times 2 blocks), but not autonomous. If Reduce == true the system will be reduced to an autonomous form and the vector bundles will only be orthogonal in a weaker sense, averaged over the phase space of the forcing dyamics.\n\nThe output is a named tuple\n\n(\n    Unreduced_Model,\n    Data_Encoder,\n    Data_Decoder,\n    Bundles,\n    Reduced_Model,\n    Reduced_Encoder,\n    Reduced_Decoder,\n)\n\nwhere\n\nUnreduced_Model is the block diagonal, but non-autonomous model.\nData_Encoder is the transformation that brings the data into the block-diagonal form.\nData_Decoder is the transformation that brings the model back into the coordinate system of the data.\nBundles is a list of ranges that point out which entries of the Unreduced_Model are a vector bundle.\nReduced_Model is the autonomous reduced model, if Reduce == true, otherwise same as Unreduced_Model.\nReduced_Encoder brings Unreduced_Model into Reduced_Model if Reduce == true otherwise identity.\nReduced_Decoder brings Reduced_Model back into Unreduced_Model if Reduce == true otherwise identity.\n\nThe parameter By_Eigen is true if the calculation is carried out by eigenvalue decomposition of the transport operator. Otherwise a specially designed Hessenberg transformation and subsequent QR iteration is carried out on the vector bundles. This latter method\n\n\n\n\n\n","category":"function"},{"location":"#InvariantModels.Select_Bundles_By_Energy","page":"Home","title":"InvariantModels.Select_Bundles_By_Energy","text":"Select_Bundles_By_Energy(\n    Index_List,\n    Data,\n    Encoded_Phase,\n    Steady_State,\n    SH,\n    Decomp;\n    How_Many,\n    Ignore_Real = true,\n)\n\nTakes the named tuple produced by Create_Linear_Decomposition and selects the most energetic How_Many vector bundles of the data. Then produces a new named touple as in Create_Linear_Decomposition, that only contains these most energetic vector bundles. The input arguments are\n\nIndex_List, Data, Encoded_Phase are the training data in the standard form.\nSteady_State is the steady state of the system estimated by Estimate_Linear_Model.\nSH is the forcing dynamics as produced by Estimate_Linear_Model.\nDecomp is the named tuple produced by Create_Linear_Decomposition.\nIgnore_Real if true the method only returns two dimensional vector bundles.   This is helpful when the data includes slowly varying DC shift with high energy that would be pick by the method otherwise.\n\n\n\n\n\n","category":"function"},{"location":"#InvariantModels.Decompose_Data","page":"Home","title":"InvariantModels.Decompose_Data","text":"Decompose_Data(Index_List, Data, Encoded_Phase, Steady_State, SH, Data_Encoder)\n\nCreates a decomposed and projected data set from the input Index_List, Data, Encoded_Phase. The Steady_State and SH are produced by Estimate_Linear_Model and Data_Encoder id produced by either Select_Bundles_By_Energy or Create_Linear_Decomposition directly.\n\n\n\n\n\n","category":"function"},{"location":"#InvariantModels.Decomposed_Data_Scaling","page":"Home","title":"InvariantModels.Decomposed_Data_Scaling","text":"Decomposed_Data_Scaling(Data_Decomp, Bundles)\n\nCreates a scaling tensor which, when applied to Data_Decomp makes each vector bundle have the same maximum amplitude, while also making the whole data set fit inside the unit ball.\n\n\n\n\n\n","category":"function"},{"location":"#InvariantModels.Generate_From_ODE","page":"Home","title":"InvariantModels.Generate_From_ODE","text":"Generate_From_ODE(\n    Vectorfield!,\n    Forcing_Map!,\n    Alpha_Map!,\n    Parameters,\n    Time_Step,\n    IC_x,\n    IC_Force,\n    IC_Alpha,\n    Trajectory_Lengths,\n)\n\nGenerates a data set from am ordinary differential equation (ODE). The ODE is defined by the three functions Vectorfield!, Forcing_Map! and Alpha_Map!.\n\nTime_Step is the sampling time interval of the soluation\nIC_x each column contains an initial condition in the state space\nIC_Force this is a storage space and will be overwritten with the actual value of the forcing state Alpha\nIC_Alpha each column contains an initial condition of the forcing state\nTrajectory_Lengths a vector of trajectory lengths\n\nThe return values are List_Of_Trajectories, List_Of_Phases, which can be further processed by identifying a linear model Estimate_Linear_Model.\n\nAn example of the ODE is\n\nfunction Vectorfield!(dx, x, u, Parameters)\n    ... dx is the dx/dt\n    ... x is the state variable vector\n    ... u is the time varying input or forcing vector\n    ... Parameters is a data structure that is passed around all function\n        and contains all auxilliary information necessary to calculate dx\n    ...\n    return x\nend\n\nfunction `Forcing_Map!`(u, Alpha, Parameters)\n    ... This function produces the forcing vector 'u'\n    ... The state variable of the forcing is `Alpha`\n    ... Parameters is a data structure that is passed around all function\n    ... The forcing depends on the state variable of the forcing `Alpha`\n    ... In this case the forcing is just a linear combination of `Alpha`\n    u[1:2] .= Parameters.Weights * Alpha\n    return u\nend\n\nfunction Alpha_Map!(x, Parameters, t)\n    ... Returns a matrix, which is the fundamental solution of the forcing dynamics\n    ... 'x' is the fundamental solution\n    ... Parameters is a data structure that is passed around all function\n    ... `t` is the independent time variable\n    return Rigid_Rotation_Matrix!(x, Parameters.Forcing_Grid, Parameters.Omega, t)\nend\n\n\n\n\n\n","category":"function"},{"location":"#InvariantModels.Encoder_Linear_Type","page":"Home","title":"InvariantModels.Encoder_Linear_Type","text":"@enum Encoder_Linear_Type begin\n    Encoder_Fixed = 0\n    Encoder_Array_Stiefel = 1\n    Encoder_Mean_Stiefel = 2\n    Encoder_Stiefel_Oblique = 3\n    Encoder_Orthogonal = 4\nend\n\nEnumeration to describe the linear part of the Encoder.\n\nEncoder_Fixed the encoder is not optimised, it is left fixed at its initial state\nEncoder_Array_Stiefel the encoder is a pointwise orthogonal set of matrices\nEncoder_Mean_Stiefel the encoder is orthogonal in an average sense over all possible forcing\nEncoder_Stiefel_Oblique the encoder consist of unit vectors for all points of forcing (not orthogonal)\nEncoder_Orthogonal the encoder is orthogonal to all linear parts of the other foliations and   this orthogonality is periodically updated with the other foliations\n\n\n\n\n\n","category":"type"},{"location":"#InvariantModels.Encoder_Nonlinear_Type","page":"Home","title":"InvariantModels.Encoder_Nonlinear_Type","text":"@enum Encoder_Nonlinear_Type begin\n    Encoder_Dense_Full = 0\n    Encoder_Dense_Latent_Linear = 1\n    Encoder_Dense_Local = 2\n    Encoder_Compressed_Full = 16\n    Encoder_Compressed_Latent_Linear = 17\n    Encoder_Compressed_Local = 18\nend\n\nEnumeration to describe the nonlinear part of the Encoder\n\nEncoder_Dense_Full the encoder is a dense polynomial without any constraints\nEncoder_Dense_Latent_Linear the encoder is a dense polynomial, but it is linear for the latent variables\nEncoder_Dense_Local the encoder is a dense polynomial, but it is locally defined about an invariant manifold\nEncoder_Compressed_Full the encoder is a compressed polynomial without any constraints\nEncoder_Compressed_Latent_Linear the encoder is a compressed polynomial, but it is linear for the latent variables\nEncoder_Compressed_Local the encoder is a compressed polynomial, but it is locally defined about an invariant manifold\n\n\n\n\n\n","category":"type"},{"location":"#InvariantModels.MultiStep_Model","page":"Home","title":"InvariantModels.MultiStep_Model","text":"MultiStep_Model(State_Dimension, Skew_Dimension, Start_Order, End_Order, Trajectories)\n\nCreate a polynomial model representation.\n\nState_Dimension dimensionality of the state space\nSkew_Dimension dimensionality of the forcin space\nStart_Order the smallest order monomial to include\nEnd_Order the greatest order monomial to include\nTrajectories number of trajectories to be represented\n\nThe model includes an identified initial condition for each fitted trajectory, which is different from the first point of the trajectory.\n\n\n\n\n\n","category":"type"},{"location":"#InvariantModels.From_Data!","page":"Home","title":"InvariantModels.From_Data!","text":"From_Data!(M::MultiStep_Model, X, Index_List, Data, Encoded_Phase, Scaling; Linear=false)\n\nCreates a polynomial model from data given by Index_List, Data, Encoded_Phase. The model is created using linear least squares and therefore not optimised. This is to provide an initial condition for optimisation later on.\n\nM, X the model representation\nIndex_List, Data and Encoded_Phase input data\nScaling a scaling factor to represent the importance of each data point\nLinear if true all nonlinear terms are zeroed\n\n\n\n\n\n","category":"function"},{"location":"#InvariantModels.Evaluate","page":"Home","title":"InvariantModels.Evaluate","text":"Evaluate(M::MultiStep_Model, X, Index_List, Data, Encoded_Phase)\n\nApplies the polynomial representation of the model M, X to the data Index_List, Data, Encoded_Phase as if each data point was an initial condition.\n\n\n\n\n\n","category":"function"},{"location":"#InvariantModels.Slice","page":"Home","title":"InvariantModels.Slice","text":"Slice(MTF::Multi_Foliation{M,State_Dimension,Skew_Dimension}, XTF, Encoded_Slice) where {M,State_Dimension,Skew_Dimension}\n\nIn case the system is parameter dependent, this function creates an autonomous slice when the encoded parameter is Encoded_Slice.\n\n\n\n\n\n","category":"function"},{"location":"#InvariantModels.Model_From_ODE","page":"Home","title":"InvariantModels.Model_From_ODE","text":"Model_From_ODE(\n    Vectorfield!,\n    Forcing_Map!,\n    Alpha_Map!,\n    IC_Force,\n    Parameters,\n    dt,\n    Time_Step;\n    State_Dimension,\n    Skew_Dimension,\n    Start_Order,\n    End_Order,\n    Steady_State::Bool = true,\n    Iterations = 100,\n)\n\nCreates a discrete-time model from the vector field Vectorfield!, Forcing_Map! and Alpha_Map!. The definition is the same as in Generate_From_ODE. The routine first calculates a steady state of the system straight from the ODE. Then it create a polynomial map about the steady state. The resulting map has its steady state at the origin.\n\ndt time step of the ODE solver\nTime_Step integration time of the ODE. One iteration of the resulting map is the same as solveing the ODE for Time_Step time.\nState_Dimension state space dimension\nSkew_Dimension forcing space dimension\nStart_Order starting order of the resulting map\nEnd_Order highest order monomial in the resulting map\nIterations how many Newto iteration to take when solving for the steady state.\n\n\n\n\n\n","category":"function"},{"location":"#InvariantModels.Model_From_Function_Alpha","page":"Home","title":"InvariantModels.Model_From_Function_Alpha","text":"Model_From_Function_Alpha(\n    Vectorfield!,\n    Alpha_Generator,\n    Parameters;\n    State_Dimension,\n    Start_Order,\n    End_Order\n)\n\nCreate a polynomial vector field by Taylor expanding the ODE given by Vectorfield! and Alpha_Generator.\n\nIt uses the same definition a a vector field as Generate_From_ODE. The difference is that Alpha_Generator is the infinitesimal generator matrix of the forcing dynamics.\n\nStart_Order and End_Order set the representing polynomial orders.\n\n\n\n\n\n","category":"function"},{"location":"#InvariantModels.Scaling_Type","page":"Home","title":"InvariantModels.Scaling_Type","text":"@enum Scaling_Type begin\n    No_Scaling = 0\n    Linear_Scaling = 1\n    Quadratic_Scaling = 2\nend\n\nDescribes how to scale the loss function as a function of the distance from the steady state.\n\n\n\n\n\n","category":"type"},{"location":"#InvariantModels.Make_Similar","page":"Home","title":"InvariantModels.Make_Similar","text":"Make_Similar(\n    MTF::Multi_Foliation{M,State_Dimension,Skew_Dimension},\n    XTF,\n    New_Trajectories::Integer,\n) where {M,State_Dimension,Skew_Dimension}\n\nCreates a new Multi_Foliation except that it will now have space for New_Trajectories initial conditions for the conjugate dynamics. This is used to create a model to evaluate testing data that has different number of trajectories than the training data.\n\n\n\n\n\n","category":"function"},{"location":"#InvariantModels.Multi_Foliation_Problem","page":"Home","title":"InvariantModels.Multi_Foliation_Problem","text":"Multi_Foliation_Problem(\n    Index_List,\n    Data_Decomposed,\n    Encoded_Phase;\n    Selection::NTuple{M, Vector{Int}},\n    Model_Orders::NTuple{M, Int},\n    Encoder_Orders::NTuple{M, Int},\n    Unreduced_Model,\n    Reduced_Model,\n    Reduced_Encoder,\n    SH,\n    Initial_Iterations = 32,\n    Scaling_Parameter = 2^(-4),\n    Initial_Scaling_Parameter = 2^(-4),\n    Scaling_Order = Linear_Scaling,\n    node_ratio = 0.8,\n    leaf_ratio = 0.8,\n    max_rank = 48,\n    Linear_Type::NTuple{M, Encoder_Linear_Type} = ntuple(i -> Encoder_Array_Stiefel, M),\n    Nonlinear_Type::NTuple{M, Encoder_Nonlinear_Type} = ntuple(i -> Encoder_Compressed_Latent_Linear, M),\n    Name = \"MTF-output\",\n    Time_Step = 1.0,\n) where {M}\n\nCreates an object with multiple foliations that can be fitted to the data.\n\nIndex_List, Data_Decomposed and Encoded_Phase The training data approximately in the cooredinates of the invariant vector bundles   of the linear part of the system about the steady state.   This transformation can be achieved by Decompose_Data   and the decomposition can be obtained by Create_Linear_Decomposition,   which in turn is obtained by an initial linear approximation of the model using Estimate_Linear_Model.\nSelection sets the vector bundles to be included in the calculated foliations.\nModel_Orders the polynomial orders of the conjugate maps for each foliation\nEncoder_Orders the polynomial orders of the conjugate maps for each foliation\nUnreduced_Model approximate linear model in the coordinate system of the data\nReduced_Model approximate (autonomous) linear model in the coordinate system of Reduced_Encoder\nReduced_Encoder a linear encoder that reduces the approximate linear map Unreduced_Model to an autonomous map.   It can also be an identity, in which case the Reduced_Model and the Unreduced_Model are the same\nSH The forcing map, identified by Estimate_Linear_Model\nInitial_Iterations how many optimisation steps to take to refine the supplied linear model to the encoded data\nScaling_Parameter the parameter the specifies data scaling\nInitial_Scaling_Parameter the parameter the specifies data scaling at the initial refinement of the model.   Choosing it too small might result in diverging calculations.\nScaling_Order whether to assign different important to various data points. This is must be one element of Scaling_Type\nnode_ratio when calculating the rank of a component in the compressed tensor representation,   by what ratio should we reduced the rank of the connecting parent node.\nleaf_ratio by how much are we allowed to reduce the rank of a leaf node from the dimeneionality of the tensor\nmax_rank the maximum rank of any node in the compressed tensor representation\nLinear_Type this is a tuple that contains what restriction should apply to the linear part of the encoder.   The values are taken from Encoder_Linear_Type\nNonlinear_Type this is a tuple that contains what restriction should apply to the nonlinear part of the encoder.   The values are taken from Encoder_Nonlinear_Type\nName this string variabel is used for the name of the data file wher the foliation is periodically save to.\nTime_Step the sampling time step of the supplied data. This is used only to display frequency information during calulation,   otherwise has no effect.\n\n\n\n\n\n","category":"type"},{"location":"#InvariantModels.Multi_Foliation_Test_Problem","page":"Home","title":"InvariantModels.Multi_Foliation_Test_Problem","text":"Multi_Foliation_Test_Problem(\n    MTFP::Multi_Foliation_Problem{M,State_Dimension,Skew_Dimension},\n    Index_List,\n    Data_Decomposed,\n    Encoded_Phase;\n    Initial_Scaling_Parameter = 2^(-4),\n) where {M,State_Dimension,Skew_Dimension}\n\nThis creates a test problem with test data included. The test data in Index_List, Data_Decomposed and Encoded_Phase. MTFP is a Multi_Foliation_Problem. Initial_Scaling_Parameter has the same meaning as in Multi_Foliation_Problem but applied to the testing data.\n\n\n\n\n\n","category":"function"},{"location":"#InvariantModels.Optimise!","page":"Home","title":"InvariantModels.Optimise!","text":"Optimise!(\n    MTFP::Multi_Foliation_Problem{M,State_Dimension,Skew_Dimension},\n    MTFP_Test::Union{Nothing,Multi_Foliation_Problem{M,State_Dimension,Skew_Dimension}} = nothing;\n    Model_Iterations = 16,\n    Encoder_Iterations = 8,\n    Steps = 128,\n    Gradient_Ratio = 2^(-7),\n    Gradient_Stop = 2^(-29),\n    Picks = [Complete_Component_Index(MTFP.XTF.x[k].x[2], (1,)) for k = 1:M],\n) where {M,State_Dimension,Skew_Dimension}\n\nFits the set of foliations defined in MTFP to the given data.\n\nMTFP      a Multi_Foliation_Problem\nMTFP_Test a Multi_Foliation_Test_Problem.   The parameters of MTFP_Test are regularly synchronised with MTFP,   except the initial condition of the latent model, which are fitted from the testing trajectories.\nModel_Iterations maximum number of optimisation steps taken when the conjugate dynamics is fitted to latent data.   The optimisation is a version of the Levenberg-Marquardt method.\nEncoder_Iterations maximum number of optimisation steps for any component of the encoder. The optimisation technique is a manifold Newton trust region method.\nSteps the number of optimisation cycles for each foliation.\nGradient_Ratio Optimisation of a component stops when the norm of the gradient has reduced by this factor\nGradient_Stop Optimisation of a component stops when the norm of the gradient has reached this value\nPicks Used for testing the code, leave as is.\n\n\n\n\n\n","category":"function"},{"location":"#InvariantModels.Find_DATA_Manifold","page":"Home","title":"InvariantModels.Find_DATA_Manifold","text":"Find_DATA_Manifold(MTF::Multi_Foliation{M,State_Dimension,Skew_Dimension}, XTF, SH, Index;\n    Radial_Order, Radial_Intervals, Radius,\n    Phase_Dimension, Transformation,\n    abstol=1e-9, reltol=1e-9, maxiters=12, initial_maxiters=200\n) where {M,State_Dimension,Skew_Dimension}\n\nCalculates a two-dimensional invariant manifold from the set of invariant foliations MTF, XTF. The calulation is for the invariant foliation selected by Index. SH is the forcing map. The rest of the function arguments are the same as in Find_MAP_Manifold\n\n\n\n\n\n","category":"function"},{"location":"#InvariantModels.Extract_Manifold_Embedding","page":"Home","title":"InvariantModels.Extract_Manifold_Embedding","text":"Extract_Manifold_Embedding(\n    MTF::Multi_Foliation{M,State_Dimension,Skew_Dimension},\n    XTF,\n    Index,\n    Data_Decomp,\n    Encoded_Phase;\n    Radial_Order,\n    Radial_Intervals,\n    Radius,\n    Phase_Dimension,\n    Output_Transformation = [],\n    Output_Inverse_Transformation = [],\n    Output_Scale,\n    abstol = 1e-9,\n    reltol = 1e-9,\n    maxiters = 24,\n    initial_maxiters = 200,\n)\n\nExtracts the invariant manifold from a set of invariant foliations MTF, XTF. The parametrisation of the foliation is the same as the identofied conjugate map. Therefore it is not directly useable to obtain backbone curves. The result is primarily used to find out the physical amplitude of an encoded data point that is mapped back onto the invariant manifold.\n\nThe input arguments are\n\nMTF, XTF represent the set of invariant foliations previously fitted to data\nIndex chooses the invariant foliation for which we calculate the invariant manifold\nRadial_Order order of the Chebyshev in the radial direction\nRadial_Intervals number of polynomials in the radial direction\nRadius the maximum radius to calculate the invariant manifold for\nPhase_Dimension the number of Fourier collocation points to use in the angular direction\nOutput_Transformation same as Data_Encoder produced by Create_Linear_Decomposition.\nOutput_Inverse_Transformation same as Data_Decoder produced by Create_Linear_Decomposition.   Note that only one of Output_Transformation or Output_Inverse_Transformation need to be specified.   If Output_Inverse_Transformation is specified, it takes precedence.\nOutput_Scale same as Data_Scale produced by Decomposed_Data_Scaling\nabstol = 1e-9 absolute tolerance when solving the invariance equation\nreltol = 1e-9 relative tolerance when solving the invariance equation\nmaxiters = 12 number of solution steps when calculating each segment of the manifold\ninitial_maxiters the maximum iteration when calculating the segment containing the steady state.   About the steady state the manifold is non-hyperbolic and therefore numerically challenging to calculate.\n\n\n\n\n\n","category":"function"},{"location":"#InvariantModels.Data_Result","page":"Home","title":"InvariantModels.Data_Result","text":"Data_Result(\nPM::Polar_Manifold{\n    State_Dimension,\n    Latent_Dimension,\n    Radial_Order,\n    Radial_Dimension,\n    Phase_Dimension,\n    Skew_Dimension,\n},\nPX,\nMIP,\nXIP,\nMTF::Multi_Foliation,\nXTF,\nIndex,\nIndex_List,\nData,\nEncoded_Phase;\nTime_Step = 1.0,\nTransformation = PM.Transformation,\nSlice_Transformation = Transformation,\nHz = false,\nDamping_By_Derivative::Bool = true,\nModel_IC = false,\n\n) where {     StateDimension,     LatentDimension,     RadialOrder,     RadialDimension,     PhaseDimension,     SkewDimension, }\n\nPlots the instantaneous frequency and damping curves for the invariant foliation at Index.\n\nPM, PX the invariant manifold calculated by Find_DATA_Manifold\nMIP, XIP the manifold embedding calculated by Extract_Manifold_Embedding\nMTF, XTF the set of invariant foliations\nIndex which invariant foliation is it calculated for\nIndex_List, Data, Encoded_Phase the training data\nTime_Step sampling time-step of data for calulating frequencies\nTransformation the transformation the brings back the data to the physical coordinate\nSlice_Transformation the transformation, in case PM, PX are calculated from a fixed parameters slice of the identified foliation.   If not a slice, should be the same as Transformation.\nHz if true frequency is displayed in Hz, otherwise it is rad/s.\nDamping_By_Derivative if true a truely instantaneous damping ratio is displayed.   If false the damping ratio commonly (and mistakenly) used in the literature is displayed\nModel_IC whether to re-calculate the initial conditions of trajectories stored in XTF\n\n\n\n\n\n","category":"function"},{"location":"#InvariantModels.Data_Error","page":"Home","title":"InvariantModels.Data_Error","text":"Data_Error(\nPM::Polar_Manifold{\n    State_Dimension,\n    Latent_Dimension,\n    Radial_Order,\n    Radial_Dimension,\n    Phase_Dimension,\n    Skew_Dimension,\n},\nPX,\nMIP,\nXIP,\nMTF::Multi_Foliation,\nXTF,\nIndex,\nIndex_List,\nData,\nEncoded_Phase;\nTransformation,\nModel_IC = false,\nIterations = 32,\n\n) where {     StateDimension,     LatentDimension,     RadialOrder,     RadialDimension,     PhaseDimension,     SkewDimension, }     )\n\nPlots the training and testing errors as a function of vibration amplitude.\n\nPM, PX the invariant manifold calculated by Find_DATA_Manifold\nMIP, XIP the manifold embedding calculated by Extract_Manifold_Embedding\nMTF, XTF the set of invariant foliations\nIndex which invariant foliation is it calculated for\nIndex_List, Data, Encoded_Phase the training data\nTransformation the transformation the brings back the data to the physical coordinate\nColor line colour of the plot\nModel_IC whether to re-calculate the initial conditions of trajectories stored in XTF\n\n\n\n\n\n","category":"function"},{"location":"#InvariantModels.Find_ODE_Manifold","page":"Home","title":"InvariantModels.Find_ODE_Manifold","text":"Find_ODE_Manifold(\n    MM::MultiStep_Model,\n    MX,\n    Generator,\n    Select;\n    Radial_Order,\n    Radial_Intervals,\n    Radius,\n    Phase_Dimension,\n    abstol = 1e-9,\n    reltol = 1e-9,\n    maxiters = 12,\n    initial_maxiters = 200,\n)\n\nCalculates a two-dimensional invariant manifold from the ODE MM, MX. The result is stored as a piecewise Chebyshev polynomial in the radial direction Fourier collocation in the angular direction.\n\nThe input arguments are\n\nMM and MX represent the polynomial vector field\nGenerator is the infinitesimal generator matrix of the forcing dynamics\nSelect chooses along which vector bundle to calculate the invariant manifold\nRadial_Order order of the Chebyshev in the radial direction\nRadial_Intervals number of polynomials in the radial direction\nRadius the maximum radius to calculate the invariant manifold for\nPhase_Dimension the number of Fourier collocation points to use in the angular direction\nabstol = 1e-9 absolute tolerance when solving the invariance equation\nreltol = 1e-9 relative tolerance when solving the invariance equation\nmaxiters = 12 number of solution steps when calculating each segment of the manifold\ninitial_maxiters the maximum iteration when calculating the segment containing the steady state.   About the steady state the manifold is non-hyperbolic and therefore numerically challenging to calculate.\n\n\n\n\n\n","category":"function"},{"location":"#InvariantModels.Find_MAP_Manifold","page":"Home","title":"InvariantModels.Find_MAP_Manifold","text":"Find_MAP_Manifold(\n    MM::MultiStep_Model{State_Dimension,Skew_Dimension,Start_Order,End_Order,Trajectories},\n    MX,\n    Select;\n    Radial_Order,\n    Radial_Intervals,\n    Radius,\n    Phase_Dimension,\n    abstol = 1e-9,\n    reltol = 1e-9,\n    maxiters = 12,\n    initial_maxiters = 200,\n) where {State_Dimension,Skew_Dimension,Start_Order,End_Order,Trajectories}\n\nCalculates a two-dimensional invariant manifold from the map MM, MX. The result is stored as a piecewise Chebyshev polynomial in the radial direction Fourier collocation in the angular direction.\n\nThe input arguments are\n\nMM and MX are the discrete-time map\nSelect chooses along which vector bundle to calculate the invariant manifold\nRadial_Order order of the Chebyshev in the radial direction\nRadial_Intervals number of polynomials in the radial direction\nRadius the maximum radius to calculate the invariant manifold for\nPhase_Dimension the number of Fourier collocation points to use in the angular direction\nabstol = 1e-9 absolute tolerance when solving the invariance equation\nreltol = 1e-9 relative tolerance when solving the invariance equation\nmaxiters = 12 number of solution steps when calculating each segment of the manifold\ninitial_maxiters the maximum iteration when calculating the segment containing the steady state.   About the steady state the manifold is non-hyperbolic and therefore numerically challenging to calculate.\n\n\n\n\n\n","category":"function"},{"location":"#InvariantModels.Model_Result","page":"Home","title":"InvariantModels.Model_Result","text":"Model_Result(\n    PM::Polar_Manifold,\n    PX;\n    Time_Step = 1.0,\n    Hz = false,\n    Damping_By_Derivative::Bool = true,\n)\n\nCalculates the instantaneous frequency and damping ratio for the invariant manifold directly calculated from an ODE or map model.\n\nPM, PX the invariant manifold calculated by Find_ODE_Manifold or Find_MAP_Manifold\nTime_Step sampling time-step of data for calulating frequencies\nHz if true frequency is displayed in Hz, otherwise it is rad/s.\nDamping_By_Derivative if true a truely instantaneous damping ratio is displayed.   If false the damping ratio commonly (and mistakenly) used in the literature is displayed\n\n\n\n\n\n","category":"function"},{"location":"#InvariantModels.Create_Plot","page":"Home","title":"InvariantModels.Create_Plot","text":"Create_Plot(; Amplitude = \"Amplitude\")\n\nCreates a figure to display the results.\n\nAmplitude is a string that will be put on the vertical axes of the plot\n\n\n\n\n\n","category":"function"},{"location":"#InvariantModels.Plot_Error_Curves!","page":"Home","title":"InvariantModels.Plot_Error_Curves!","text":"Plot_Error_Curves!(\n    fig, Error_Curves, Data_Max_Pre;\n    Color = Makie.wong_colors()[2],\n    Dense_Style = :solid,\n    Max_Style = :dot,\n    Mean_Style = :solid,\n    Amplitude_Scale = 1,\n)\n\nfig is the figure to plot\nError_Curves produced by Data_Error\nData_Max_Pre the maximum amplitude to consider\nColor line colour\nDense_Style line style for density\nMax_Style line style for maximum error\nMean_Style line style for mean error\nAmplitude_Scale a scaling factor for amplitudes. This can be use because the result is in different units.\n\n\n\n\n\n","category":"function"},{"location":"#InvariantModels.Plot_Error_Trace","page":"Home","title":"InvariantModels.Plot_Error_Trace","text":"Plot_Error_Trace(\n    fig,\n    Index,\n    Train_Trace,\n    Test_Trace = nothing;\n    Train_Color = Makie.wong_colors()[1],\n    Test_Color = Makie.wong_colors()[2],\n)\n\nAdds the training and testing errors to the figure fig for the foliation selected by Index. Train_Trace and Test_Trace are produced by Optimise!.\n\n\n\n\n\n","category":"function"},{"location":"#InvariantModels.Annotate_Plot!","page":"Home","title":"InvariantModels.Annotate_Plot!","text":"Annotate_Plot!(fig)\n\nPerform the final annotation of the figure, so that it is ready for display.\n\n\n\n\n\n","category":"function"}]
}
